Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 202846)
+++ CMakeLists.txt	(working copy)
@@ -81,6 +81,7 @@
   Mips
   MBlaze
   MSP430
+  AVR
   NVPTX
   PowerPC
   Sparc
Index: configure
===================================================================
--- configure	(revision 202846)
+++ configure	(working copy)
@@ -1445,7 +1445,7 @@
   --enable-targets        Build specific host targets: all or
                           target1,target2,... Valid targets are: host, x86,
                           x86_64, sparc, powerpc, arm, aarch64, mips, hexagon,
-                          xcore, msp430, nvptx, systemz, and cpp (default=all)
+                          xcore, msp430, avr, nvptx, systemz, and cpp (default=all)
   --enable-experimental-targets
                           Build experimental host targets: disable or
                           target1,target2,... (default=disable)
@@ -4023,6 +4023,7 @@
   mipsel-* | mips64el-*)  llvm_cv_target_arch="Mips" ;;
   xcore-*)                llvm_cv_target_arch="XCore" ;;
   msp430-*)               llvm_cv_target_arch="MSP430" ;;
+  avr-*)				  llvm_cv_target_arch="AVR" ;;
   hexagon-*)              llvm_cv_target_arch="Hexagon" ;;
   mblaze-*)               llvm_cv_target_arch="MBlaze" ;;
   nvptx-*)                llvm_cv_target_arch="NVPTX" ;;
@@ -5395,6 +5396,8 @@
  ;;
     MSP430)      TARGET_HAS_JIT=0
  ;;
+    AVR)      TARGET_HAS_JIT=0
+ ;;
     Hexagon)     TARGET_HAS_JIT=0
  ;;
     MBlaze)      TARGET_HAS_JIT=0
@@ -5651,6 +5654,7 @@
         mips64el) TARGETS_TO_BUILD="Mips $TARGETS_TO_BUILD" ;;
         xcore)    TARGETS_TO_BUILD="XCore $TARGETS_TO_BUILD" ;;
         msp430)   TARGETS_TO_BUILD="MSP430 $TARGETS_TO_BUILD" ;;
+        avr)      TARGETS_TO_BUILD="AVR $TARGETS_TO_BUILD" ;;
         cpp)      TARGETS_TO_BUILD="CppBackend $TARGETS_TO_BUILD" ;;
         hexagon)  TARGETS_TO_BUILD="Hexagon $TARGETS_TO_BUILD" ;;
         mblaze)   TARGETS_TO_BUILD="MBlaze $TARGETS_TO_BUILD" ;;
@@ -5667,6 +5671,7 @@
             MBlaze)      TARGETS_TO_BUILD="MBlaze $TARGETS_TO_BUILD" ;;
             XCore)       TARGETS_TO_BUILD="XCore $TARGETS_TO_BUILD" ;;
             MSP430)      TARGETS_TO_BUILD="MSP430 $TARGETS_TO_BUILD" ;;
+            AVR)      TARGETS_TO_BUILD="AVR $TARGETS_TO_BUILD" ;;
             Hexagon)     TARGETS_TO_BUILD="Hexagon $TARGETS_TO_BUILD" ;;
             NVPTX)       TARGETS_TO_BUILD="NVPTX $TARGETS_TO_BUILD" ;;
             SystemZ)     TARGETS_TO_BUILD="SystemZ $TARGETS_TO_BUILD" ;;
Index: include/llvm/ADT/Triple.h
===================================================================
--- include/llvm/ADT/Triple.h	(revision 202846)
+++ include/llvm/ADT/Triple.h	(working copy)
@@ -51,6 +51,7 @@
     mips64,  // MIPS64: mips64
     mips64el,// MIPS64EL: mips64el
     msp430,  // MSP430: msp430
+	avr,
     ppc,     // PPC: powerpc
     ppc64,   // PPC64: powerpc64, ppu
     r600,    // R600: AMD GPUs HD2XXX - HD6XXX
Index: lib/Support/Triple.cpp
===================================================================
--- lib/Support/Triple.cpp	(revision 202846)
+++ lib/Support/Triple.cpp	(working copy)
@@ -27,6 +27,7 @@
   case mips64:  return "mips64";
   case mips64el:return "mips64el";
   case msp430:  return "msp430";
+  case avr:  return "avr";
   case ppc64:   return "powerpc64";
   case ppc:     return "powerpc";
   case r600:    return "r600";
@@ -165,6 +166,7 @@
     .Case("mips64", mips64)
     .Case("mips64el", mips64el)
     .Case("msp430", msp430)
+    .Case("avr", avr)
     .Case("ppc64", ppc64)
     .Case("ppc32", ppc)
     .Case("ppc", ppc)
@@ -231,6 +233,7 @@
     .Case("thumb", Triple::thumb)
     .StartsWith("thumbv", Triple::thumb)
     .Case("msp430", Triple::msp430)
+    .Case("avr", Triple::avr)
     .Cases("mips", "mipseb", "mipsallegrex", Triple::mips)
     .Cases("mipsel", "mipsallegrexel", Triple::mipsel)
     .Cases("mips64", "mips64eb", Triple::mips64)
@@ -666,6 +669,7 @@
     return 0;
 
   case llvm::Triple::msp430:
+  case llvm::Triple::avr:
     return 16;
 
   case llvm::Triple::amdil:
@@ -718,6 +722,7 @@
   case Triple::UnknownArch:
   case Triple::aarch64:
   case Triple::msp430:
+  case Triple::avr:
   case Triple::systemz:
     T.setArch(UnknownArch);
     break;
@@ -762,6 +767,7 @@
   case Triple::le32:
   case Triple::mblaze:
   case Triple::msp430:
+  case Triple::avr:
   case Triple::r600:
   case Triple::tce:
   case Triple::thumb:
Index: lib/Target/AVR/AVR.h
===================================================================
--- lib/Target/AVR/AVR.h	(revision 0)
+++ lib/Target/AVR/AVR.h	(revision 0)
@@ -0,0 +1,47 @@
+//==-- AVR.h - Top-level interface for AVR representation --*- C++ -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the entry points for global functions defined in
+// the LLVM AVR backend.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TARGET_AVR_H
+#define LLVM_TARGET_AVR_H
+
+#include "MCTargetDesc/AVRMCTargetDesc.h"
+#include "llvm/Target/TargetMachine.h"
+
+namespace AVRCC {
+  // AVR specific condition code.
+  enum CondCodes {
+    COND_E  = 0,  
+    COND_NE = 1,  
+    COND_HS = 2,  
+    COND_LO = 3,  
+    COND_GE = 4,
+    COND_L  = 5,
+
+    COND_INVALID = -1
+  };
+}
+
+namespace llvm {
+  class AVRTargetMachine;
+  class FunctionPass;
+  class formatted_raw_ostream;
+
+  FunctionPass *createAVRISelDag(AVRTargetMachine &TM,
+                                    CodeGenOpt::Level OptLevel);
+
+  //FunctionPass *createAVRBranchSelectionPass();
+
+} // end namespace llvm;
+
+#endif
Index: lib/Target/AVR/AVR.td
===================================================================
--- lib/Target/AVR/AVR.td	(revision 0)
+++ lib/Target/AVR/AVR.td	(revision 0)
@@ -0,0 +1,59 @@
+//===- AVR.td - Describe the AVR Target Machine ---------*- tblgen -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source 
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+// This is the top level entry point for the AVR target.
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Target-independent interfaces
+//===----------------------------------------------------------------------===//
+
+include "llvm/Target/Target.td"
+
+//===----------------------------------------------------------------------===//
+// AVR supported processors.
+//===----------------------------------------------------------------------===//
+class Proc<string Name, list<SubtargetFeature> Features>
+ : Processor<Name, NoItineraries, Features>;
+
+def : Proc<"generic",         []>;
+
+//===----------------------------------------------------------------------===//
+// Register File Description
+//===----------------------------------------------------------------------===//
+
+include "AVRRegisterInfo.td"
+
+//===----------------------------------------------------------------------===//
+// Calling Convention Description
+//===----------------------------------------------------------------------===//
+
+include "AVRCallingConv.td"
+
+//===----------------------------------------------------------------------===//
+// Instruction Descriptions
+//===----------------------------------------------------------------------===//
+
+include "AVRInstrInfo.td"
+
+def AVRInstrInfo : InstrInfo;
+
+def AVRInstPrinter : AsmWriter {
+  string AsmWriterClassName  = "InstPrinter";
+   bit isMCAsmWriter = 1;
+}
+
+//===----------------------------------------------------------------------===//
+// Target Declaration
+//===----------------------------------------------------------------------===//
+
+ def AVR : Target {
+  let InstructionSet = AVRInstrInfo;
+  let AssemblyWriters = [AVRInstPrinter];
+}
+
Index: lib/Target/AVR/AVRAsmPrinter.cpp
===================================================================
--- lib/Target/AVR/AVRAsmPrinter.cpp	(revision 0)
+++ lib/Target/AVR/AVRAsmPrinter.cpp	(revision 0)
@@ -0,0 +1,156 @@
+//===-- AVRAsmPrinter.cpp - AVR LLVM assembly writer ----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains a printer that converts from our internal representation
+// of machine-dependent LLVM code to the AVR assembly language.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "asm-printer"
+#include "AVR.h"
+#include "AVRInstrInfo.h"
+#include "AVRMCInstLower.h"
+#include "AVRTargetMachine.h"
+#include "InstPrinter/AVRInstPrinter.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Assembly/Writer.h"
+#include "llvm/CodeGen/AsmPrinter.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineConstantPool.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCStreamer.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/Target/Mangler.h"
+#include "llvm/Support/TargetRegistry.h"
+#include "llvm/Support/raw_ostream.h"
+using namespace llvm;
+
+namespace {
+  class AVRAsmPrinter : public AsmPrinter {
+  public:
+    AVRAsmPrinter(TargetMachine &TM, MCStreamer &Streamer)
+      : AsmPrinter(TM, Streamer) {}
+
+    virtual const char *getPassName() const {
+      return "AVR Assembly Printer";
+    }
+
+    void printOperand(const MachineInstr *MI, int OpNum,
+                      raw_ostream &O, const char* Modifier = 0);
+    void printSrcMemOperand(const MachineInstr *MI, int OpNum,
+                            raw_ostream &O);
+    bool PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
+                         unsigned AsmVariant, const char *ExtraCode,
+                         raw_ostream &O);
+    bool PrintAsmMemoryOperand(const MachineInstr *MI,
+                               unsigned OpNo, unsigned AsmVariant,
+                               const char *ExtraCode, raw_ostream &O);
+    void EmitInstruction(const MachineInstr *MI);
+  };
+} // end of anonymous namespace
+
+
+void AVRAsmPrinter::printOperand(const MachineInstr *MI, int OpNum,
+                                    raw_ostream &O, const char *Modifier) {
+  const MachineOperand &MO = MI->getOperand(OpNum);
+  switch (MO.getType()) {
+  default: assert(0 && "Not implemented yet!");
+  case MachineOperand::MO_Register:
+    O << AVRInstPrinter::getRegisterName(MO.getReg());
+    return;
+  case MachineOperand::MO_Immediate:
+    O << MO.getImm();
+    return;
+  case MachineOperand::MO_MachineBasicBlock:
+    O << *MO.getMBB()->getSymbol();
+    return;
+  case MachineOperand::MO_GlobalAddress: {
+    bool isMemOp  = Modifier && !strcmp(Modifier, "mem");
+    uint64_t Offset = MO.getOffset();
+
+    // If the global address expression is a part of displacement field with a
+    // register base, we should not emit any prefix symbol here, e.g.
+    //   mov.w &foo, r1
+    // vs
+    //   mov.w glb(r1), r2
+    // Otherwise (!) AVR-as will silently miscompile the output :(
+    //if (!Modifier || strcmp(Modifier, "nohash"))
+    //  O << (isMemOp ? '&' : '#');
+    if (Offset)
+      O << '(' << Offset << '+';
+
+    O << *Mang->getSymbol(MO.getGlobal());
+
+    if (Offset)
+      O << ')';
+
+    return;
+  }
+  case MachineOperand::MO_ExternalSymbol: {
+    bool isMemOp  = Modifier && !strcmp(Modifier, "mem");
+    //O << (isMemOp ? '&' : '#');
+    O << MAI->getGlobalPrefix() << MO.getSymbolName();
+    return;
+  }
+  }
+}
+
+void AVRAsmPrinter::printSrcMemOperand(const MachineInstr *MI, int OpNum,
+                                          raw_ostream &O) {
+  const MachineOperand &Base = MI->getOperand(OpNum);
+  const MachineOperand &Disp = MI->getOperand(OpNum+1);
+
+  printOperand(MI, OpNum, O);
+  O << '+';
+  printOperand(MI, OpNum+1, O, "nohash");
+
+}
+
+/// PrintAsmOperand - Print out an operand for an inline asm expression.
+///
+bool AVRAsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
+                                       unsigned AsmVariant,
+                                       const char *ExtraCode, raw_ostream &O) {
+  // Does this asm operand have a single letter operand modifier?
+  if (ExtraCode && ExtraCode[0])
+    return true; // Unknown modifier.
+
+  printOperand(MI, OpNo, O);
+  return false;
+}
+
+bool AVRAsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI,
+                                             unsigned OpNo, unsigned AsmVariant,
+                                             const char *ExtraCode,
+                                             raw_ostream &O) {
+  if (ExtraCode && ExtraCode[0]) {
+    return true; // Unknown modifier.
+  }
+  printSrcMemOperand(MI, OpNo, O);
+  return false;
+}
+
+//===----------------------------------------------------------------------===//
+void AVRAsmPrinter::EmitInstruction(const MachineInstr *MI) {
+  AVRMCInstLower MCInstLowering(OutContext, *Mang, *this);
+
+  MCInst TmpInst;
+  MCInstLowering.Lower(MI, TmpInst);
+  OutStreamer.EmitInstruction(TmpInst);
+}
+
+// Force static initialization.
+extern "C" void LLVMInitializeAVRAsmPrinter() {
+  RegisterAsmPrinter<AVRAsmPrinter> X(TheAVRTarget);
+}
Index: lib/Target/AVR/AVRCallingConv.td
===================================================================
--- lib/Target/AVR/AVRCallingConv.td	(revision 0)
+++ lib/Target/AVR/AVRCallingConv.td	(revision 0)
@@ -0,0 +1,42 @@
+//==- AVRCallingConv.td - Calling Conventions for AVR -*- tablegen -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+// This describes the calling conventions for AVR architecture.
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// AVR Return Value Calling Convention
+//===----------------------------------------------------------------------===//
+def RetCC_AVR : CallingConv<[
+  CCIfType<[i8], CCAssignToReg<[R24]>>,
+
+  // i16 are returned in registers R25, R24
+  CCIfType<[i16], CCAssignToReg<[R25W]>>
+
+  // i32 are returned in registers R25, R24, R23, R22
+  //CCIfType<[i32], CCAssignToReg<[R22, R23, R24, R25]>>,
+
+  // i64 are returned in registers R25, R24, R23, R22, R21, R20, R19, R18
+  //CCIfType<[i32], CCAssignToReg<[R18, R19, R20, R21, R22, R23, R24, R25]>>
+]>;
+
+//===----------------------------------------------------------------------===//
+// AVR Argument Calling Conventions
+//===----------------------------------------------------------------------===//
+def CC_AVR : CallingConv<[
+  // Promote i8 arguments to i16.
+  CCIfType<[i8], CCAssignToReg<[R24, R22, R20, R18, R16, R14, R12]>>,
+
+  // The first 4 integer arguments of non-varargs functions are passed in
+  // integer registers.
+  CCIfNotVarArg<CCIfType<[i16], CCAssignToReg<[R25W]>>>,
+
+  // Integer values get stored in stack slots that are 2 bytes in
+  // size and 2-byte aligned.
+  CCIfType<[i16], CCAssignToStack<2, 2>>
+]>;
Index: lib/Target/AVR/AVRFrameLowering.cpp
===================================================================
--- lib/Target/AVR/AVRFrameLowering.cpp	(revision 0)
+++ lib/Target/AVR/AVRFrameLowering.cpp	(revision 0)
@@ -0,0 +1,220 @@
+//======-- AVRFrameLowering.cpp - AVR Frame Information -------=========//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the AVR implementation of TargetFrameLowering class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVRFrameLowering.h"
+#include "AVRInstrInfo.h"
+#include "AVRMachineFunctionInfo.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/Target/TargetOptions.h"
+#include "llvm/Support/CommandLine.h"
+
+using namespace llvm;
+
+// For the AVR, accessing stack slots without a stack frame is expensive, as SP is not a register
+// that can be used for indirect load. Using SP as the base register will therefore involve
+// a couple of INs into an indexed register followed by an indexed load or store. Doing this for
+// every stack slot access is going to blow up the function size very quickly.
+// So, if stack slots are needed, setup the stack frame with Y always.
+
+bool AVRFrameLowering::hasFP(const MachineFunction &MF) const {
+  const MachineFrameInfo *MFI = MF.getFrameInfo();
+  const AVRMachineFunctionInfo *AVRFI = MF.getInfo<AVRMachineFunctionInfo>();
+  const uint64_t NumStackBytes = MFI->getStackSize() - AVRFI->getCalleeSavedFrameSize();
+
+  return (MF.getTarget().Options.DisableFramePointerElim(MF) ||
+          MF.getFrameInfo()->hasVarSizedObjects() ||
+          MFI->isFrameAddressTaken());
+}
+
+bool AVRFrameLowering::hasReservedCallFrame(const MachineFunction &MF) const {
+  return !MF.getFrameInfo()->hasVarSizedObjects();
+}
+
+void AVRFrameLowering::emitPrologue(MachineFunction &MF) const {
+  
+  MachineBasicBlock &MBB = MF.front();   // Prolog goes in entry BB
+  MachineFrameInfo *MFI = MF.getFrameInfo();
+  AVRMachineFunctionInfo *AVRFI = MF.getInfo<AVRMachineFunctionInfo>();
+  const AVRInstrInfo &TII =
+    *static_cast<const AVRInstrInfo*>(MF.getTarget().getInstrInfo());
+
+  MachineBasicBlock::iterator MBBI = MBB.begin();
+  DebugLoc DL = MBBI != MBB.end() ? MBBI->getDebugLoc() : DebugLoc();
+
+  // Get the number of bytes to allocate from the FrameInfo.
+  uint64_t StackSize = MFI->getStackSize();
+
+  // Calculate required stack adjustment
+  uint64_t FrameSize = StackSize;
+  uint64_t NumBytes = FrameSize - AVRFI->getCalleeSavedFrameSize();
+
+  if (hasFP(MF)) {
+
+    // Save FPW into the appropriate stack slot...
+    BuildMI(MBB, MBBI, DL, TII.get(AVR::PUSH))
+      .addReg(AVR::R28, RegState::Kill);
+
+    BuildMI(MBB, MBBI, DL, TII.get(AVR::PUSH))
+      .addReg(AVR::R29, RegState::Kill);
+   }
+
+
+  // Skip the callee-saved push instructions.
+  while (MBBI != MBB.end() && (MBBI->getOpcode() == AVR::PUSH))
+    ++MBBI;
+
+  if (MBBI != MBB.end())
+    DL = MBBI->getDebugLoc();
+
+  // Write IN R30, SPL
+  //       SBCI R30, NumBytes
+  //       OUT SPL, R30
+
+  if (NumBytes) { // adjust stack pointer: SPW -= numbytes
+      MachineInstr *MI =
+        BuildMI(MBB, MBBI, DL, TII.get(AVR::IN), AVR::R29)
+        .addReg(AVR::SPL);
+        BuildMI(MBB, MBBI, DL, TII.get(AVR::IN), AVR::R28)
+        .addReg(AVR::SPH);
+        BuildMI(MBB, MBBI, DL, TII.get(AVR::SUB8wri), AVR::R28)
+        .addReg(AVR::R30).addImm(NumBytes);
+        BuildMI(MBB, MBBI, DL, TII.get(AVR::OUT), AVR::SPL)
+        .addReg(AVR::R28);
+        BuildMI(MBB, MBBI, DL, TII.get(AVR::OUT), AVR::SPH)
+        .addReg(AVR::R29);
+      // The SRW implicit def is dead.
+      //MI->getOperand(3).setIsDead();
+
+      }
+
+  // Set the FP register to the updated SP. Setting it at the top
+  // of the stack frame allows std y+d instructions (stack grows down).
+  if (hasFP(MF) || NumBytes) {
+
+    // Mark the FramePtr as live-in in every block except the entry.
+    for (MachineFunction::iterator I = llvm::next(MF.begin()), E = MF.end();
+        I != E; ++I) {
+      I->addLiveIn(AVR::R28);
+      I->addLiveIn(AVR::R29);
+    }
+  }
+}
+
+void AVRFrameLowering::emitEpilogue(MachineFunction &MF,
+                                       MachineBasicBlock &MBB) const {
+  const MachineFrameInfo *MFI = MF.getFrameInfo();
+  AVRMachineFunctionInfo *AVRFI = MF.getInfo<AVRMachineFunctionInfo>();
+  const AVRInstrInfo &TII =
+    *static_cast<const AVRInstrInfo*>(MF.getTarget().getInstrInfo());
+
+  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
+  unsigned RetOpcode = MBBI->getOpcode();
+  DebugLoc DL = MBBI->getDebugLoc();
+
+  switch (RetOpcode) {
+  case AVR::RET:
+  case AVR::RETI: break;  // These are ok
+  default:
+    llvm_unreachable("Can only insert epilog into returning blocks");
+  }
+
+  // Get the number of bytes to allocate from the FrameInfo
+  uint64_t StackSize = MFI->getStackSize();
+  unsigned CSSize = AVRFI->getCalleeSavedFrameSize();
+  uint64_t FrameSize = StackSize;
+  uint64_t NumBytes = FrameSize - CSSize;
+
+  if (hasFP(MF)) {
+    // Calculate required stack adjustment
+
+    // pop FPW.
+    BuildMI(MBB, MBBI, DL, TII.get(AVR::POP), AVR::R29);
+    BuildMI(MBB, MBBI, DL, TII.get(AVR::POP), AVR::R28);
+  }
+
+  // Skip the callee-saved pop instructions.
+  while (MBBI != MBB.begin()) {
+    MachineBasicBlock::iterator PI = prior(MBBI);
+    unsigned Opc = PI->getOpcode();
+    if (Opc != AVR::POP && !PI->isTerminator())
+      break;
+    --MBBI;
+  }
+
+  DL = MBBI->getDebugLoc();
+
+  if (MFI->hasVarSizedObjects()) {
+    assert(false && "Variable sized objects not handled yet.");
+  } else {
+    // adjust stack pointer back: SPW += numbytes by repeatedly doing POP r0
+    if (NumBytes) {
+      for (uint64_t i = 0; i<NumBytes; ++i)
+      {
+      MachineInstr *MI =
+        BuildMI(MBB, MBBI, DL, TII.get(AVR::POP))
+        .addReg(AVR::R0);
+      }
+    }
+  }
+}
+
+// FIXME: Can we eleminate these in favour of generic code?
+bool
+AVRFrameLowering::spillCalleeSavedRegisters(MachineBasicBlock &MBB,
+                                           MachineBasicBlock::iterator MI,
+                                        const std::vector<CalleeSavedInfo> &CSI,
+                                        const TargetRegisterInfo *TRI) const {
+  if (CSI.empty())
+    return false;
+
+  DebugLoc DL;
+  if (MI != MBB.end()) DL = MI->getDebugLoc();
+
+  MachineFunction &MF = *MBB.getParent();
+  const TargetInstrInfo &TII = *MF.getTarget().getInstrInfo();
+  AVRMachineFunctionInfo *MFI = MF.getInfo<AVRMachineFunctionInfo>();
+  MFI->setCalleeSavedFrameSize(CSI.size() * 2);
+
+  for (unsigned i = CSI.size(); i != 0; --i) {
+    unsigned Reg = CSI[i-1].getReg();
+    // Add the callee-saved register as live-in. It's killed at the spill.
+    MBB.addLiveIn(Reg);
+    BuildMI(MBB, MI, DL, TII.get(AVR::PUSH))
+      .addReg(Reg, RegState::Kill);
+  }
+  return true;
+}
+
+bool
+AVRFrameLowering::restoreCalleeSavedRegisters(MachineBasicBlock &MBB,
+                                                 MachineBasicBlock::iterator MI,
+                                        const std::vector<CalleeSavedInfo> &CSI,
+                                        const TargetRegisterInfo *TRI) const {
+  if (CSI.empty())
+    return false;
+
+  DebugLoc DL;
+  if (MI != MBB.end()) DL = MI->getDebugLoc();
+
+  MachineFunction &MF = *MBB.getParent();
+  const TargetInstrInfo &TII = *MF.getTarget().getInstrInfo();
+
+  for (unsigned i = 0, e = CSI.size(); i != e; ++i)
+    BuildMI(MBB, MI, DL, TII.get(AVR::POP), CSI[i].getReg());
+
+  return true;
+}
Index: lib/Target/AVR/AVRFrameLowering.h
===================================================================
--- lib/Target/AVR/AVRFrameLowering.h	(revision 0)
+++ lib/Target/AVR/AVRFrameLowering.h	(revision 0)
@@ -0,0 +1,50 @@
+//==- AVRFrameLowering.h - Define frame lowering for AVR --*- C++ -*--==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef AVR_FRAMEINFO_H
+#define AVR_FRAMEINFO_H
+
+#include "AVR.h"
+#include "llvm/Target/TargetFrameLowering.h"
+
+namespace llvm {
+  class AVRSubtarget;
+
+class AVRFrameLowering : public TargetFrameLowering {
+
+public:
+  explicit AVRFrameLowering()
+    : TargetFrameLowering(TargetFrameLowering::StackGrowsDown, 2, -2){
+  }
+
+  /// emitProlog/emitEpilog - These methods insert prolog and epilog code into
+  /// the function.
+  void emitPrologue(MachineFunction &MF) const;
+  void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const;
+
+  bool spillCalleeSavedRegisters(MachineBasicBlock &MBB,
+                                 MachineBasicBlock::iterator MI,
+                                 const std::vector<CalleeSavedInfo> &CSI,
+                                 const TargetRegisterInfo *TRI) const;
+  bool restoreCalleeSavedRegisters(MachineBasicBlock &MBB,
+                                   MachineBasicBlock::iterator MI,
+                                   const std::vector<CalleeSavedInfo> &CSI,
+                                   const TargetRegisterInfo *TRI) const;
+
+  bool hasFP(const MachineFunction &MF) const;
+  bool hasReservedCallFrame(const MachineFunction &MF) const;
+};
+
+} // End llvm namespace
+
+#endif
Index: lib/Target/AVR/AVRInstrFormats.td
===================================================================
--- lib/Target/AVR/AVRInstrFormats.td	(revision 0)
+++ lib/Target/AVR/AVRInstrFormats.td	(revision 0)
@@ -0,0 +1,211 @@
+//===- AVRInstrFormats.td - AVR Instruction Formats-----*- tblgen -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source 
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+//  Describe AVR instructions format here
+//
+
+// Format specifies the encoding used by the instruction.  This is part of the
+// ad-hoc solution used to emit machine instruction encodings by our machine
+// code emitter.
+class Format<bits<2> val> {
+  bits<2> Value = val;
+}
+
+def PseudoFrm   : Format<0>;
+def SingleOpFrm : Format<1>;
+def DoubleOpFrm : Format<2>;
+def CondJumpFrm : Format<3>;
+
+class SourceMode<bits<2> val> {
+  bits<2> Value = val;
+}
+
+def SrcReg      : SourceMode<0>;
+def SrcMem      : SourceMode<1>;
+def SrcIndReg   : SourceMode<2>;
+def SrcPostInc  : SourceMode<3>;
+def SrcImm      : SourceMode<3>;
+
+class DestMode<bit val> {
+  bit Value = val;
+}
+
+def DstReg      : DestMode<0>;
+def DstMem      : DestMode<1>;
+
+class SizeVal<bits<3> val> {
+  bits<3> Value = val;
+}
+
+def SizeUnknown : SizeVal<0>; // Unknown / unset size
+def SizeSpecial : SizeVal<1>; // Special instruction, e.g. pseudo
+def Size2Bytes  : SizeVal<2>;
+def Size4Bytes  : SizeVal<3>;
+def Size6Bytes  : SizeVal<4>;
+
+// Generic AVR Format
+class AVRInst<dag outs, dag ins, SizeVal sz, Format f,
+                 string asmstr> : Instruction {
+  field bits<16> Inst;
+
+  let Namespace = "AVR";
+
+  dag OutOperandList = outs;
+  dag InOperandList  = ins;
+
+  Format Form = f;
+  SizeVal Sz = sz;
+
+  // Define how we want to layout our TargetSpecific information field... This
+  // should be kept up-to-date with the fields in the AVRInstrInfo.h file.
+  let TSFlags{1-0} = Form.Value;
+  let TSFlags{4-2} = Sz.Value;
+
+  let AsmString   = asmstr;
+}
+
+// FIXME: Create different classes for different addressing modes.
+
+// AVR Double Operand (Format I) Instructions
+class IForm<bits<4> opcode, DestMode dest, bit bw, SourceMode src, SizeVal sz,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : AVRInst<outs, ins, sz, DoubleOpFrm, asmstr> {
+  let Pattern = pattern;
+
+  DestMode ad = dest;
+  SourceMode as = src;
+  
+  let Inst{12-15} = opcode;
+  let Inst{7}     = ad.Value;
+  let Inst{6}     = bw;
+  let Inst{4-5}   = as.Value;
+}
+
+// 8 bit IForm instructions
+class IForm8<bits<4> opcode, DestMode dest, SourceMode src, SizeVal sz,
+             dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm<opcode, dest, 1, src, sz, outs, ins, asmstr, pattern>;
+
+class I8rr<bits<4> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm8<opcode, DstReg, SrcReg, Size2Bytes, outs, ins, asmstr, pattern>;
+
+class I8ri<bits<4> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm8<opcode, DstReg, SrcImm, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class I8rm<bits<4> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm8<opcode, DstReg, SrcMem, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class I8mr<bits<4> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm8<opcode, DstMem, SrcReg, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class I8mi<bits<4> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm8<opcode, DstMem, SrcImm, Size6Bytes, outs, ins, asmstr, pattern>;
+
+class I8mm<bits<4> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm8<opcode, DstMem, SrcMem, Size6Bytes, outs, ins, asmstr, pattern>;
+
+// 16 bit IForm instructions
+class IForm16<bits<4> opcode, DestMode dest, SourceMode src, SizeVal sz,
+              dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm<opcode, dest, 0, src, sz, outs, ins, asmstr, pattern>;
+
+class I16rr<bits<4> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm16<opcode, DstReg, SrcReg, Size2Bytes, outs, ins, asmstr, pattern>;
+
+class I16ri<bits<4> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm16<opcode, DstReg, SrcImm, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class I16rm<bits<4> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm16<opcode, DstReg, SrcMem, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class I16mr<bits<4> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm16<opcode, DstMem, SrcReg, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class I16mi<bits<4> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm16<opcode, DstMem, SrcImm, Size6Bytes, outs, ins, asmstr, pattern>;
+
+class I16mm<bits<4> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IForm16<opcode, DstMem, SrcMem, Size6Bytes, outs, ins, asmstr, pattern>;
+
+// AVR Single Operand (Format II) Instructions
+class IIForm<bits<9> opcode, bit bw, SourceMode src, SizeVal sz,
+             dag outs, dag ins, string asmstr, list<dag> pattern>
+  : AVRInst<outs, ins, sz, SingleOpFrm, asmstr> {
+  let Pattern = pattern;
+  
+  SourceMode as = src;
+
+  let Inst{7-15} = opcode;
+  let Inst{6}    = bw;
+  let Inst{4-5}  = as.Value;
+}
+
+// 8 bit IIForm instructions
+class IIForm8<bits<9> opcode, SourceMode src, SizeVal sz,
+              dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm<opcode, 1, src, sz, outs, ins, asmstr, pattern>;
+
+class II8r<bits<9> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm8<opcode, SrcReg, Size2Bytes, outs, ins, asmstr, pattern>;
+
+class II8m<bits<9> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm8<opcode, SrcMem, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class II8i<bits<9> opcode,
+           dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm8<opcode, SrcImm, Size4Bytes, outs, ins, asmstr, pattern>;
+
+// 16 bit IIForm instructions
+class IIForm16<bits<9> opcode, SourceMode src, SizeVal sz,
+               dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm<opcode, 0, src, sz, outs, ins, asmstr, pattern>;
+
+class II16r<bits<9> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm16<opcode, SrcReg, Size2Bytes, outs, ins, asmstr, pattern>;
+
+class II16m<bits<9> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm16<opcode, SrcMem, Size4Bytes, outs, ins, asmstr, pattern>;
+
+class II16i<bits<9> opcode,
+            dag outs, dag ins, string asmstr, list<dag> pattern>
+  : IIForm16<opcode, SrcImm, Size4Bytes, outs, ins, asmstr, pattern>;
+
+// AVR Conditional Jumps Instructions
+class CJForm<bits<3> opcode, bits<3> cond,
+             dag outs, dag ins, string asmstr, list<dag> pattern>
+  : AVRInst<outs, ins, Size2Bytes, CondJumpFrm, asmstr> {
+  let Pattern = pattern;
+  
+  let Inst{13-15} = opcode;
+  let Inst{10-12} = cond;
+}
+
+// Pseudo instructions
+class Pseudo<dag outs, dag ins, string asmstr, list<dag> pattern>
+  : AVRInst<outs, ins, SizeSpecial, PseudoFrm, asmstr> {
+  let Pattern = pattern;
+  let Inst{15-0} = 0;
+}
Index: lib/Target/AVR/AVRInstrInfo.cpp
===================================================================
--- lib/Target/AVR/AVRInstrInfo.cpp	(revision 0)
+++ lib/Target/AVR/AVRInstrInfo.cpp	(revision 0)
@@ -0,0 +1,332 @@
+//===- AVRInstrInfo.cpp - AVR Instruction Information ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the AVR implementation of the TargetInstrInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVR.h"
+#include "AVRInstrInfo.h"
+#include "AVRMachineFunctionInfo.h"
+#include "AVRTargetMachine.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/TargetRegistry.h"
+
+#define GET_INSTRINFO_CTOR
+#include "AVRGenInstrInfo.inc"
+
+using namespace llvm;
+
+AVRInstrInfo::AVRInstrInfo(AVRTargetMachine &tm)
+  : AVRGenInstrInfo(AVR::ADJCALLSTACKDOWN, AVR::ADJCALLSTACKUP),
+    RI(tm, *this), TM(tm) {}
+
+void AVRInstrInfo::storeRegToStackSlot(MachineBasicBlock &MBB,
+                                          MachineBasicBlock::iterator MI,
+                                    unsigned SrcReg, bool isKill, int FrameIdx,
+                                          const TargetRegisterClass *RC,
+                                          const TargetRegisterInfo *TRI) const {
+  DebugLoc DL;
+  if (MI != MBB.end()) DL = MI->getDebugLoc();
+  MachineFunction &MF = *MBB.getParent();
+  MachineFrameInfo &MFI = *MF.getFrameInfo();
+
+  MachineMemOperand *MMO =
+    MF.getMachineMemOperand(MachinePointerInfo::getFixedStack(FrameIdx),
+                            MachineMemOperand::MOStore,
+                            MFI.getObjectSize(FrameIdx),
+                            MFI.getObjectAlignment(FrameIdx));
+
+  if (RC == &AVR::GR8RegClass)
+    BuildMI(MBB, MI, DL, get(AVR::MOV8mr))
+      .addFrameIndex(FrameIdx).addImm(0)
+      .addReg(SrcReg, getKillRegState(isKill)).addMemOperand(MMO);
+  else
+    llvm_unreachable("Cannot store this register to stack slot!");
+}
+
+void AVRInstrInfo::loadRegFromStackSlot(MachineBasicBlock &MBB,
+                                           MachineBasicBlock::iterator MI,
+                                           unsigned DestReg, int FrameIdx,
+                                           const TargetRegisterClass *RC,
+                                           const TargetRegisterInfo *TRI) const{
+  DebugLoc DL;
+  if (MI != MBB.end()) DL = MI->getDebugLoc();
+  MachineFunction &MF = *MBB.getParent();
+  MachineFrameInfo &MFI = *MF.getFrameInfo();
+
+  MachineMemOperand *MMO =
+    MF.getMachineMemOperand(MachinePointerInfo::getFixedStack(FrameIdx),
+                            MachineMemOperand::MOLoad,
+                            MFI.getObjectSize(FrameIdx),
+                            MFI.getObjectAlignment(FrameIdx));
+
+  if (RC == &AVR::GR16RegClass)
+    BuildMI(MBB, MI, DL, get(AVR::MOV16rm))
+      .addReg(DestReg).addFrameIndex(FrameIdx).addImm(0).addMemOperand(MMO);
+  else if (RC == &AVR::GR8RegClass)
+    BuildMI(MBB, MI, DL, get(AVR::MOV8rm))
+      .addReg(DestReg).addFrameIndex(FrameIdx).addImm(0).addMemOperand(MMO);
+  else
+    llvm_unreachable("Cannot store this register to stack slot!");
+}
+
+void AVRInstrInfo::copyPhysReg(MachineBasicBlock &MBB,
+                                  MachineBasicBlock::iterator I, DebugLoc DL,
+                                  unsigned DestReg, unsigned SrcReg,
+                                  bool KillSrc) const {
+  unsigned Opc;
+  if (AVR::GR16RegClass.contains(DestReg, SrcReg))
+    Opc = AVR::MOV16rr;
+  else if (AVR::GR8RegClass.contains(DestReg, SrcReg))
+    Opc = AVR::MOV8rr;
+  else if (AVR::IO8RegClass.contains(DestReg))
+    Opc = AVR::OUT;
+  else if (AVR::IO8RegClass.contains(SrcReg))
+    Opc = AVR::IN;
+  else
+    llvm_unreachable("Impossible reg-to-reg copy");
+
+  BuildMI(MBB, I, DL, get(Opc), DestReg)
+    .addReg(SrcReg, getKillRegState(KillSrc));
+}
+
+unsigned AVRInstrInfo::RemoveBranch(MachineBasicBlock &MBB) const {
+  //MachineBasicBlock::iterator I = MBB.end();
+  unsigned Count = 0;
+
+  /*
+  while (I != MBB.begin()) {
+    --I;
+    if (I->isDebugValue())
+      continue;
+    if (I->getOpcode() != AVR::JMP &&
+        I->getOpcode() != AVR::JCC &&
+        I->getOpcode() != AVR::Br &&
+        I->getOpcode() != AVR::Bm)
+      break;
+    // Remove the branch.
+    I->eraseFromParent();
+    I = MBB.end();
+    ++Count;
+  }
+  */
+
+  return Count;
+}
+
+bool AVRInstrInfo::
+ReverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {
+  /*
+  assert(Cond.size() == 1 && "Invalid Xbranch condition!");
+
+  AVRCC::CondCodes CC = static_cast<AVRCC::CondCodes>(Cond[0].getImm());
+
+  switch (CC) {
+  default:
+    assert(0 && "Invalid branch condition!");
+    break;
+  case AVRCC::COND_E:
+    CC = AVRCC::COND_NE;
+    break;
+  case AVRCC::COND_NE:
+    CC = AVRCC::COND_E;
+    break;
+  case AVRCC::COND_L:
+    CC = AVRCC::COND_GE;
+    break;
+  case AVRCC::COND_GE:
+    CC = AVRCC::COND_L;
+    break;
+  case AVRCC::COND_HS:
+    CC = AVRCC::COND_LO;
+    break;
+  case AVRCC::COND_LO:
+    CC = AVRCC::COND_HS;
+    break;
+  }
+
+  Cond[0].setImm(CC);
+  */
+  return false;
+}
+
+bool AVRInstrInfo::isUnpredicatedTerminator(const MachineInstr *MI) const {
+  if (!MI->isTerminator()) return false;
+
+  // Conditional branch is a special case.
+  if (MI->isBranch() && !MI->isBarrier())
+    return true;
+  if (!MI->isPredicable())
+    return true;
+  return !isPredicated(MI);
+}
+
+bool AVRInstrInfo::AnalyzeBranch(MachineBasicBlock &MBB,
+                                    MachineBasicBlock *&TBB,
+                                    MachineBasicBlock *&FBB,
+                                    SmallVectorImpl<MachineOperand> &Cond,
+                                    bool AllowModify) const {
+  // Start from the bottom of the block and work up, examining the
+  // terminator instructions.
+  MachineBasicBlock::iterator I = MBB.end();
+  while (I != MBB.begin()) {
+    --I;
+    if (I->isDebugValue())
+      continue;
+
+    // Working from the bottom, when we see a non-terminator
+    // instruction, we're done.
+    if (!isUnpredicatedTerminator(I))
+      break;
+
+    // A terminator that isn't a branch can't easily be handled
+    // by this analysis.
+    if (!I->isBranch())
+      return true;
+
+    // Handle unconditional branches.
+    if (I->getOpcode() == AVR::JMP) {
+      if (!AllowModify) {
+        TBB = I->getOperand(0).getMBB();
+        continue;
+      }
+
+      // If the block has any instructions after a JMP, delete them.
+      while (llvm::next(I) != MBB.end())
+        llvm::next(I)->eraseFromParent();
+      Cond.clear();
+      FBB = 0;
+
+      // Delete the JMP if it's equivalent to a fall-through.
+      if (MBB.isLayoutSuccessor(I->getOperand(0).getMBB())) {
+        TBB = 0;
+        I->eraseFromParent();
+        I = MBB.end();
+        continue;
+      }
+
+      // TBB is used to indicate the unconditinal destination.
+      TBB = I->getOperand(0).getMBB();
+      continue;
+    }
+
+    // Handle conditional branches.
+    assert(I->getOpcode() == AVR::JCC && "Invalid conditional branch");
+    AVRCC::CondCodes BranchCode =
+      static_cast<AVRCC::CondCodes>(I->getOperand(1).getImm());
+    if (BranchCode == AVRCC::COND_INVALID)
+      return true;  // Can't handle weird stuff.
+
+    // Working from the bottom, handle the first conditional branch.
+    if (Cond.empty()) {
+      FBB = TBB;
+      TBB = I->getOperand(0).getMBB();
+      Cond.push_back(MachineOperand::CreateImm(BranchCode));
+      continue;
+    }
+
+    // Handle subsequent conditional branches. Only handle the case where all
+    // conditional branches branch to the same destination.
+    assert(Cond.size() == 1);
+    assert(TBB);
+
+    // Only handle the case where all conditional branches branch to
+    // the same destination.
+    if (TBB != I->getOperand(0).getMBB())
+      return true;
+
+    AVRCC::CondCodes OldBranchCode = (AVRCC::CondCodes)Cond[0].getImm();
+    // If the conditions are the same, we can leave them alone.
+    if (OldBranchCode == BranchCode)
+      continue;
+
+    return true;
+  }
+
+  return false;
+}
+
+unsigned
+AVRInstrInfo::InsertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,
+                              MachineBasicBlock *FBB,
+                              const SmallVectorImpl<MachineOperand> &Cond,
+                              DebugLoc DL) const {
+  // Shouldn't be a fall through.
+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");
+  assert((Cond.size() == 1 || Cond.size() == 0) &&
+         "AVR branch conditions have one component!");
+
+  if (Cond.empty()) {
+    // Unconditional branch?
+    assert(!FBB && "Unconditional branch with multiple successors!");
+    BuildMI(&MBB, DL, get(AVR::JMP)).addMBB(TBB);
+    return 1;
+  }
+
+  // Conditional branch.
+  unsigned Count = 0;
+  BuildMI(&MBB, DL, get(AVR::JCC)).addMBB(TBB).addImm(Cond[0].getImm());
+  ++Count;
+
+  if (FBB) {
+    // Two-way Conditional branch. Insert the second branch.
+    BuildMI(&MBB, DL, get(AVR::JMP)).addMBB(FBB);
+    ++Count;
+  }
+  return Count;
+}
+
+/// GetInstSize - Return the number of bytes of code the specified
+/// instruction may be.  This returns the maximum number of bytes.
+///
+unsigned AVRInstrInfo::GetInstSizeInBytes(const MachineInstr *MI) const {
+  const MCInstrDesc &Desc = MI->getDesc();
+
+  switch (Desc.TSFlags & AVRII::SizeMask) {
+  default:
+    switch (Desc.getOpcode()) {
+    default:
+      assert(0 && "Unknown instruction size!");
+    case TargetOpcode::PROLOG_LABEL:
+    case TargetOpcode::EH_LABEL:
+    case TargetOpcode::IMPLICIT_DEF:
+    case TargetOpcode::KILL:
+    case TargetOpcode::DBG_VALUE:
+      return 0;
+    case TargetOpcode::INLINEASM: {
+      const MachineFunction *MF = MI->getParent()->getParent();
+      const TargetInstrInfo &TII = *MF->getTarget().getInstrInfo();
+      return TII.getInlineAsmLength(MI->getOperand(0).getSymbolName(),
+                                    *MF->getTarget().getMCAsmInfo());
+    }
+    }
+  case AVRII::SizeSpecial:
+    /*
+    switch (MI->getOpcode()) {
+    default:
+      assert(0 && "Unknown instruction size!");
+    case AVR::SAR8r1c:
+    case AVR::SAR16r1c:
+    */
+      return 4;
+    //}
+  case AVRII::Size2Bytes:
+    return 2;
+  case AVRII::Size4Bytes:
+    return 4;
+  case AVRII::Size6Bytes:
+    return 6;
+  }
+
+  return 6;
+}
Index: lib/Target/AVR/AVRInstrInfo.h
===================================================================
--- lib/Target/AVR/AVRInstrInfo.h	(revision 0)
+++ lib/Target/AVR/AVRInstrInfo.h	(revision 0)
@@ -0,0 +1,92 @@
+//===- AVRInstrInfo.h - AVR Instruction Information -------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the AVR implementation of the TargetInstrInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TARGET_AVRINSTRINFO_H
+#define LLVM_TARGET_AVRINSTRINFO_H
+
+#include "llvm/Target/TargetInstrInfo.h"
+#include "AVRRegisterInfo.h"
+
+#define GET_INSTRINFO_HEADER
+#include "AVRGenInstrInfo.inc"
+
+namespace llvm {
+
+class AVRTargetMachine;
+
+/// AVRII - This namespace holds all of the target specific flags that
+/// instruction info tracks.
+///
+namespace AVRII {
+  enum {
+    SizeShift   = 2,
+    SizeMask    = 7 << SizeShift,
+
+    SizeUnknown = 0 << SizeShift,
+    SizeSpecial = 1 << SizeShift,
+    Size2Bytes  = 2 << SizeShift,
+    Size4Bytes  = 3 << SizeShift,
+    Size6Bytes  = 4 << SizeShift
+  };
+}
+
+class AVRInstrInfo : public AVRGenInstrInfo {
+  const AVRRegisterInfo RI;
+  AVRTargetMachine &TM;
+public:
+  explicit AVRInstrInfo(AVRTargetMachine &TM);
+
+  /// getRegisterInfo - TargetInstrInfo is a superset of MRegister info.  As
+  /// such, whenever a client has an instance of instruction info, it should
+  /// always be able to get register info as well (through this method).
+  ///
+  virtual const TargetRegisterInfo &getRegisterInfo() const { return RI; }
+
+  void copyPhysReg(MachineBasicBlock &MBB,
+                   MachineBasicBlock::iterator I, DebugLoc DL,
+                   unsigned DestReg, unsigned SrcReg,
+                   bool KillSrc) const;
+
+  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,
+                                   MachineBasicBlock::iterator MI,
+                                   unsigned SrcReg, bool isKill,
+                                   int FrameIndex,
+                                   const TargetRegisterClass *RC,
+                                   const TargetRegisterInfo *TRI) const;
+  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,
+                                    MachineBasicBlock::iterator MI,
+                                    unsigned DestReg, int FrameIdx,
+                                    const TargetRegisterClass *RC,
+                                    const TargetRegisterInfo *TRI) const;
+
+  unsigned GetInstSizeInBytes(const MachineInstr *MI) const;
+
+  // Branch folding goodness
+  bool ReverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const;
+  bool isUnpredicatedTerminator(const MachineInstr *MI) const;
+  bool AnalyzeBranch(MachineBasicBlock &MBB,
+                     MachineBasicBlock *&TBB, MachineBasicBlock *&FBB,
+                     SmallVectorImpl<MachineOperand> &Cond,
+                     bool AllowModify) const;
+
+  unsigned RemoveBranch(MachineBasicBlock &MBB) const;
+  unsigned InsertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,
+                        MachineBasicBlock *FBB,
+                        const SmallVectorImpl<MachineOperand> &Cond,
+                        DebugLoc DL) const;
+
+};
+
+}
+
+#endif
Index: lib/Target/AVR/AVRInstrInfo.td
===================================================================
--- lib/Target/AVR/AVRInstrInfo.td	(revision 0)
+++ lib/Target/AVR/AVRInstrInfo.td	(revision 0)
@@ -0,0 +1,420 @@
+//===- AVRInstrInfo.td - AVR Instruction defs -----------*- tblgen-*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source 
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file describes the AVR instructions in TableGen format.
+//
+//===----------------------------------------------------------------------===//
+
+include "AVRInstrFormats.td"
+
+//===----------------------------------------------------------------------===//
+// Type Constraints.
+//===----------------------------------------------------------------------===//
+class SDTCisI8<int OpNum> : SDTCisVT<OpNum, i8>;
+class SDTCisI16<int OpNum> : SDTCisVT<OpNum, i16>;
+
+//===----------------------------------------------------------------------===//
+// Type Profiles.
+//===----------------------------------------------------------------------===//
+def SDT_AVRCall         : SDTypeProfile<0, -1, [SDTCisVT<0, iPTR>]>;
+def SDT_AVRCallSeqStart : SDCallSeqStart<[SDTCisVT<0, i16>]>;
+def SDT_AVRCallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i16>, SDTCisVT<1, i16>]>;
+def SDT_AVRWrapper      : SDTypeProfile<1, 1, [SDTCisSameAs<0, 1>,
+                                                  SDTCisPtrTy<0>]>;
+def SDT_AVRCmp          : SDTypeProfile<0, 2, [SDTCisSameAs<0, 1>]>;
+def SDT_AVRBrCC         : SDTypeProfile<0, 2, [SDTCisVT<0, OtherVT>,
+                                                  SDTCisVT<1, i8>]>;
+def SDT_AVRSelectCC     : SDTypeProfile<1, 3, [SDTCisSameAs<0, 1>,
+                                                  SDTCisSameAs<1, 2>, 
+                                                  SDTCisVT<3, i8>]>;
+def SDT_AVRShift        : SDTypeProfile<1, 2, [SDTCisSameAs<0, 1>, SDTCisI8<1>, SDTCisI8<0>,
+                                                  SDTCisI8<2>]>;
+
+//===----------------------------------------------------------------------===//
+// AVR Specific Node Definitions.
+//===----------------------------------------------------------------------===//
+def AVRretflag  : SDNode<"AVRISD::RET_FLAG", SDTNone,
+                       [SDNPHasChain, SDNPOptInGlue]>;
+def AVRretiflag : SDNode<"AVRISD::RETI_FLAG", SDTNone,
+                       [SDNPHasChain, SDNPOptInGlue]>;
+
+def AVRrlc     : SDNode<"AVRISD::RLC", SDTIntUnaryOp, []>;
+def AVRrrc     : SDNode<"AVRISD::RRC", SDTIntUnaryOp, []>;
+def AVRshlc    : SDNode<"AVRISD::SHLC", SDTIntUnaryOp, []>;
+def AVRsrac    : SDNode<"AVRISD::SRAC", SDTIntUnaryOp, []>;
+def AVRsrlc    : SDNode<"AVRISD::SRLC", SDTIntUnaryOp, []>;
+
+def AVRcall    : SDNode<"AVRISD::CALL", SDT_AVRCall,
+                     [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue, SDNPVariadic]>;
+def AVRcallseq_start :
+                 SDNode<"ISD::CALLSEQ_START", SDT_AVRCallSeqStart,
+                        [SDNPHasChain, SDNPOutGlue]>;
+def AVRcallseq_end :
+                 SDNode<"ISD::CALLSEQ_END",   SDT_AVRCallSeqEnd,
+                        [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
+def AVRWrapper : SDNode<"AVRISD::Wrapper", SDT_AVRWrapper>;
+def AVRcmp     : SDNode<"AVRISD::CMP", SDT_AVRCmp, [SDNPOutGlue]>;
+def AVRbrcc    : SDNode<"AVRISD::BR_CC", SDT_AVRBrCC,
+                            [SDNPHasChain, SDNPInGlue]>;
+def AVRselectcc: SDNode<"AVRISD::SELECT_CC", SDT_AVRSelectCC,
+                            [SDNPInGlue]>;
+def AVRshl     : SDNode<"AVRISD::SHL", SDT_AVRShift, []>;
+def AVRsrl     : SDNode<"AVRISD::SRL", SDT_AVRShift, []>;
+def AVRsra     : SDNode<"AVRISD::SRA", SDT_AVRShift, []>;
+
+//===----------------------------------------------------------------------===//
+// AVR Operand Definitions.
+//===----------------------------------------------------------------------===//
+
+// Address operands
+def memsrc : Operand<i16> {
+  let PrintMethod = "printSrcMemOperand";
+  let MIOperandInfo = (ops GR16, i16imm);
+}
+
+def memdst : Operand<i16> {
+  let PrintMethod = "printSrcMemOperand";
+  let MIOperandInfo = (ops GR16, i16imm);
+}
+
+// Short jump targets have OtherVT type and are printed as pcrel imm values.
+def jmptarget : Operand<OtherVT> {
+  let PrintMethod = "printPCRelImmOperand";
+}
+
+// Operand for printing out a condition code.
+def cc : Operand<i8> {
+  let PrintMethod = "printCCOperand";
+}
+
+//===----------------------------------------------------------------------===//
+// AVR Complex Pattern Definitions.
+//===----------------------------------------------------------------------===//
+
+def addr : ComplexPattern<iPTR, 2, "SelectAddr", [], []>;
+
+//===----------------------------------------------------------------------===//
+// Pattern Fragments
+def zextloadi16i8 : PatFrag<(ops node:$ptr), (i16 (zextloadi8 node:$ptr))>;
+def  extloadi16i8 : PatFrag<(ops node:$ptr), (i16 ( extloadi8 node:$ptr))>;
+def and_su : PatFrag<(ops node:$lhs, node:$rhs), (and node:$lhs, node:$rhs), [{
+  return N->hasOneUse();
+}]>;
+//===----------------------------------------------------------------------===//
+
+// Instruction list..
+
+// ADJCALLSTACKDOWN/UP implicitly use/def SP because they may be expanded into
+// a stack adjustment and the codegen must know that they may modify the stack
+// pointer before prolog-epilog rewriting occurs.
+// Pessimistically assume ADJCALLSTACKDOWN / ADJCALLSTACKUP will become
+// sub / add which can clobber SRW.
+let Defs = [SPH, SPL], Uses = [SPH, SPL] in {
+def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i16imm:$amt),
+                              "#ADJCALLSTACKDOWN",
+                              [(AVRcallseq_start timm:$amt)]>;
+def ADJCALLSTACKUP   : Pseudo<(outs), (ins i16imm:$amt1, i16imm:$amt2),
+                              "#ADJCALLSTACKUP",
+                              [(AVRcallseq_end timm:$amt1, timm:$amt2)]>;
+}
+
+let neverHasSideEffects = 1 in
+def NOP : Pseudo<(outs), (ins), "nop", []>;
+//===----------------------------------------------------------------------===//
+//  Control Flow Instructions...
+//
+
+// FIXME: Provide proper encoding!
+let isReturn = 1, isTerminator = 1, isBarrier = 1 in {
+  def RET  : IForm16<0x0, DstReg, SrcPostInc, Size2Bytes,
+                     (outs), (ins), "ret",  [(AVRretflag)]>;
+  def RETI : II16r<0x0, (outs), (ins), "reti", [(AVRretiflag)]>;
+}
+
+let isBranch = 1, isTerminator = 1 in {
+
+// FIXME: expand opcode & cond field for branches!
+
+// Direct branch
+let isBarrier = 1 in {
+  // Short branch
+  def JMP : CJForm<0, 0, (outs), (ins jmptarget:$dst),
+                   "jmp\t$dst",
+                   [(br bb:$dst)]>;
+}
+
+// Conditional branches
+
+let Uses = [SREG] in 
+  def JCC : CJForm<0, 0,
+                   (outs), (ins jmptarget:$dst, cc:$cc),
+                   "br$cc\t$dst",
+                   [(AVRbrcc bb:$dst, imm:$cc)]>;
+} // isBranch, isTerminator
+
+//===----------------------------------------------------------------------===//
+//  Call Instructions...
+//
+let isCall = 1 in
+  // All calls clobber the non-callee saved registers. SPW is marked as
+  // a use to prevent stack-pointer assignments that appear immediately
+  // before calls from potentially appearing dead. Uses for argument
+  // registers are added manually.
+  let Defs = [R18, R19, R20, R21, R22, R23, R24, R25, R26, R27, R30, R31],
+      Uses = [SPL, SPH] in {
+    def CALL     : II16i<0x0,
+                          (outs), (ins i16imm:$dst, variable_ops),
+                          "call\t$dst", [(AVRcall imm:$dst)]>;
+  }
+
+
+//  IO Instructions
+//
+def OUT      : I8rr<0x0,
+		   (outs IO8:$dst), (ins GR8:$src),
+                   "out \t{$dst, $src}",
+                    []>;
+
+def IN      : I8rr<0x0,
+		   (outs GR8:$dst), (ins IO8:$src),
+                   "in \t{$dst, $src}",
+                    []>;
+
+//===----------------------------------------------------------------------===//
+//  Miscellaneous Instructions...
+//
+let Defs = [SPH, SPL], Uses = [SPH, SPL], neverHasSideEffects=1 in {
+let mayLoad = 1 in
+def POP      : II8r<0x0,
+                       (outs GR8:$reg), (ins), "pop \t$reg", []>;
+
+let mayStore = 1 in
+def PUSH  : II8r<0x0,
+                     (outs), (ins GR8:$reg), "push \t$reg",[]>;
+}
+
+//===----------------------------------------------------------------------===//
+// Move Instructions
+
+// FIXME: Provide proper encoding!
+let neverHasSideEffects = 1 in {
+def MOV8rr  : I8rr<0x0,
+                   (outs GR8:$dst), (ins GR8:$src),
+                   "mov \t{$dst, $src}",
+                   []>;
+def MOV16rr : I16rr<0x0,
+                    (outs GR16:$dst), (ins GR16:$src),
+                    "movw \t{$dst, $src}",
+                    []>;
+}
+
+// FIXME: Provide proper encoding!
+let isAsCheapAsAMove = 1 in {
+def MOV8ri  : I8ri<0x0,
+                   (outs IGR8:$dst), (ins i8imm:$src),
+                   "ldi\t{$dst, $src}",
+                   [(set IGR8:$dst, imm:$src)]>;
+
+}
+
+let canFoldAsLoad = 1, isReMaterializable = 1 in {
+def MOV8rm  : I8rm<0x0,
+                   (outs GR8:$dst), (ins memsrc:$src),
+                   "lds\t{$dst, $src}",
+                   [(set GR8:$dst, (load addr:$src))]>;
+def MOV16rm : I16rm<0x0,
+                    (outs GR16:$dst), (ins memsrc:$src),
+                    "lds\t{$dst, $src}",
+                    [(set GR16:$dst, (load addr:$src))]>;
+}
+def MOV8rm_INDEX  : I8rm<0x0,
+                   (outs GR8:$dst), (ins memsrc:$src),
+                   "ldd\t{$dst, $src}",
+                   []>;
+def MOV16rm_INDEX : I16rm<0x0,
+                    (outs GR16:$dst), (ins memsrc:$src),
+                    "lds\t{$dst, $src}",
+                    []>;
+
+
+/// Any instruction that defines a 8-bit result leaves the high half of the
+// register. Truncate can be lowered to EXTRACT_SUBREG, and CopyFromReg may
+// be copying from a truncate, but any other 8-bit operation will zero-extend
+// up to 16 bits.
+def def8 : PatLeaf<(i8 GR8:$src), [{
+  return N->getOpcode() != ISD::TRUNCATE &&
+         N->getOpcode() != TargetOpcode::EXTRACT_SUBREG &&
+         N->getOpcode() != ISD::CopyFromReg;
+}]>;
+
+// In the case of a 8-bit def that is known to implicitly zero-extend,
+// we can use a SUBREG_TO_REG.
+//def : Pat<(i16 (zext def8:$src)),
+//          (SUBREG_TO_REG (i16 0), GR8:$src, subreg_8bit)>;
+
+
+def MOV8mr  : I8mr<0x0,
+                   (outs), (ins memdst:$dst, GR8:$src),
+                   "sts\t{$dst, $src}",
+                   [(store GR8:$src, addr:$dst)]>;
+def MOV16mr : I16mr<0x0,
+                    (outs), (ins memdst:$dst, GR16:$src),
+                    "sts\t{$dst, $src}",
+                    [(store GR16:$src, addr:$dst)]>;
+
+def MOV8imr : I8mr<0x0,
+                   (outs), (ins INDR16:$dst, GR8:$src),
+                   "st\t{$dst, $src}",
+                   [(store GR8:$src, addr:$dst)]>;
+
+def MOV8mr_INDEX : I8mr<0x0,
+                   (outs), (ins memsrc:$dst, GR8:$src),
+                   "std\t{$dst, $src}",
+                   []>;
+
+//===----------------------------------------------------------------------===//
+// Arithmetic Instructions
+
+let Constraints = "$src = $dst" in {
+
+let Defs = [SREG] in {
+
+let isCommutable = 1 in { // X = ADD Y, Z  == X = ADD Z, Y
+
+def ADD8rr  : I8rr<0x0,
+                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
+                   "add \t{$dst, $src2}",
+                   [(set GR8:$dst, (add GR8:$src, GR8:$src2))
+                   ]>;
+
+
+def ADC8rr  : I8rr<0x0,
+                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
+                   "adc\t{$dst, $src2}",
+                   [(set GR8:$dst, (adde GR8:$src, GR8:$src2)),
+                    (implicit SREG)]>;
+
+}
+
+
+def SUB8rr  : I8rr<0x0,
+                   (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
+                   "sbc \t{$dst, $src2}",
+                   [(set GR8:$dst, (sub GR8:$src, GR8:$src2))
+                   ]>;
+
+def SUB8ri  : I8ri<0x0,
+                   (outs GR8:$dst), (ins GR8:$src, i8imm:$src2),
+                   "sbci \t{$dst, $src2}",
+                   [(set GR8:$dst, (sub GR8:$src, imm:$src2))]>;
+
+def SUB8wri  : I8ri<0x0,
+                   (outs IGR8:$dst), (ins IGR8:$src, i8imm:$src2),
+                   "sbiw \t{$dst, $src2}",
+                   []>;
+}
+
+def AND8rr   : I8rr<0x0,
+                    (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
+                    "and \t{$dst, $src2}",
+                    [(set GR8:$dst, (and GR8:$src, GR8:$src2)) ]>;
+
+def AND8ri   : I8ri<0x0,
+                    (outs IGR8:$dst), (ins IGR8:$src, i8imm:$src2),
+                    "andi \t{$dst, $src2}",
+                    [(set IGR8:$dst, (and IGR8:$src, imm:$src2)) ]>;
+
+def OR8rr   : I8ri<0x0,
+                    (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
+                    "or \t{$dst, $src2}",
+                    [(set GR8:$dst, (or GR8:$src, GR8:$src2)) ]>;
+
+def OR8ri   : I8ri<0x0,
+                    (outs IGR8:$dst), (ins IGR8:$src, i8imm:$src2),
+                    "ori \t{$dst, $src2}",
+                    [(set IGR8:$dst, (or IGR8:$src, imm:$src2)) ]>;
+def XOR8rr   : I8rr<0x0,
+                    (outs GR8:$dst), (ins GR8:$src, GR8:$src2),
+                    "eor \t{$dst, $src2}",
+                    [(set GR8:$dst, (xor GR8:$src, GR8:$src2)) ]>;
+}
+
+// Integer comparisons
+let Defs = [SREG] in {
+def CMP8rr  : I8rr<0x0,
+                   (outs), (ins GR8:$src, GR8:$src2),
+                   "cp\t{$src, $src2}",
+                   [(AVRcmp GR8:$src, GR8:$src2), (implicit SREG)]>;
+
+def CMP8ri  : I8ri<0x0,
+                   (outs), (ins GR8:$src, i8imm:$src2),
+                   "cpi\t{$src, $src2}",
+                   [(AVRcmp GR8:$src, imm:$src2), (implicit SREG)]>;
+}
+
+let usesCustomInserter = 1 in {
+
+  let Defs = [SREG] in {
+  def Shl8     : Pseudo<(outs GR8:$dst), (ins GR8:$src, GR8:$cnt),
+                        "# Shl8 PSEUDO",
+                        [(set GR8:$dst, (AVRshl GR8:$src, GR8:$cnt))]>;
+
+
+  def Srl8     : Pseudo<(outs GR8:$dst), (ins GR8:$src, GR8:$cnt),
+                        "# Srl8 PSEUDO",
+                        [(set GR8:$dst, (AVRsrl GR8:$src, GR8:$cnt))]>;
+
+  def Sra8     : Pseudo<(outs GR8:$dst), (ins GR8:$src, GR8:$cnt),
+                        "# Sra8 PSEUDO",
+                        [(set GR8:$dst, (AVRsra GR8:$src, GR8:$cnt))]>;
+
+  }
+}
+
+let Constraints = "$src = $dst" in
+{
+  def Shl8r1  : I8rr<0x0,
+      (outs GR8:$dst), (ins GR8:$src),
+      "lsl \t{$dst}",
+      [(set GR8:$dst, (AVRshlc GR8:$src))]>;
+      
+  def Shr8r1  : I8rr<0x0,
+      (outs GR8:$dst), (ins GR8:$src),
+      "lsr \t{$dst}",
+      [(set GR8:$dst, (AVRsrlc GR8:$src))]>;
+
+  def Shr8r1c  : I8rr<0x0,
+      (outs GR8:$dst), (ins GR8:$src),
+      "asr \t{$dst}",
+      [(set GR8:$dst, (AVRsrac GR8:$src))]>;
+
+  def ROL8r1c  : I8rr<0x0,
+      (outs GR8:$dst), (ins GR8:$src),
+      "rol\t$dst",
+      [(set GR8:$dst, (AVRrlc GR8:$src))]>;
+
+  def ROR8r1c  : Pseudo<(outs GR8:$dst), (ins GR8:$src),
+        "ror\t $dst",
+      [(set GR8:$dst, (AVRrrc GR8:$src))]>;
+}
+// calls
+def : Pat<(AVRcall (i16 tglobaladdr:$dst)),
+          (CALL tglobaladdr:$dst)>;
+def : Pat<(AVRcall (i16 texternalsym:$dst)),
+          (CALL texternalsym:$dst)>;
+
+
+def LO16 : SDNodeXForm<imm, [{
+  return CurDAG->getTargetConstant((unsigned char)N->getZExtValue());
+}]>;
+
+def HI16 : SDNodeXForm<imm, [{
+  return CurDAG->getTargetConstant((unsigned char)(N->getZExtValue() >> 8));
+}]>;
+
Index: lib/Target/AVR/AVRISelLowering.cpp
===================================================================
--- lib/Target/AVR/AVRISelLowering.cpp	(revision 0)
+++ lib/Target/AVR/AVRISelLowering.cpp	(revision 0)
@@ -0,0 +1,896 @@
+//===-- AVRISelLowering.cpp - AVR DAG Lowering Implementation  ------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the AVRTargetLowering class.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "avr-lower"
+
+#include "AVRISelLowering.h"
+#include "AVR.h"
+#include "AVRMachineFunctionInfo.h"
+#include "AVRTargetMachine.h"
+#include "AVRRegisterInfo.h"
+#include "llvm/CodeGen/CallingConvLower.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/SelectionDAGISel.h"
+#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "llvm/CodeGen/ValueTypes.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+using namespace llvm;
+
+AVRTargetLowering::AVRTargetLowering(AVRTargetMachine &tm) :
+  TargetLowering(tm, new TargetLoweringObjectFileELF()),
+  TM(tm) {
+
+
+  // Set up the register classes.
+
+  // Compute derived properties from the register classes
+  computeRegisterProperties();
+
+  // Provide all sorts of operation actions
+
+  // Division is expensive
+  setIntDivIsCheap(false);
+
+  setIndexedLoadAction(ISD::POST_INC, MVT::i16, Legal);
+  setIndexedLoadAction(ISD::PRE_DEC, MVT::i16, Legal);
+
+  setLoadExtAction(ISD::EXTLOAD,  MVT::i1,  Promote);
+  setLoadExtAction(ISD::SEXTLOAD, MVT::i1,  Promote);
+  setLoadExtAction(ISD::ZEXTLOAD, MVT::i1,  Promote);
+  setLoadExtAction(ISD::SEXTLOAD, MVT::i8,  Expand);
+  setLoadExtAction(ISD::SEXTLOAD, MVT::i16, Expand);
+
+  setOperationAction(ISD::DYNAMIC_STACKALLOC, MVT::i8, Expand);
+  setOperationAction(ISD::DYNAMIC_STACKALLOC, MVT::i16, Expand);
+
+  setTruncStoreAction(MVT::i16, MVT::i8, Expand);
+
+  setOperationAction(ISD::GlobalAddress,    MVT::i16,   Custom);
+  //setOperationAction(ISD::ExternalSymbol,   MVT::i16,   Custom);
+  setOperationAction(ISD::BlockAddress,     MVT::i16,   Custom);
+
+  setOperationAction(ISD::BR_CC,            MVT::i8,    Custom);
+  setOperationAction(ISD::BR_CC,            MVT::i16,   Custom);
+  setOperationAction(ISD::BRCOND,           MVT::Other, Expand);
+
+  setOperationAction(ISD::SHL,            MVT::i8,    Custom);
+  setOperationAction(ISD::SRL,            MVT::i8,    Custom);
+  setOperationAction(ISD::SRA,            MVT::i8,    Custom);
+  setOperationAction(ISD::ROTR,           MVT::i8,    Expand);
+  setOperationAction(ISD::ROTL,           MVT::i8,    Expand);
+
+  setBooleanContents(ZeroOrOneBooleanContent);
+  setBooleanVectorContents(ZeroOrOneBooleanContent); // FIXME: Is this correct?
+
+  setMinFunctionAlignment(2);
+  setPrefFunctionAlignment(2);
+}
+
+SDValue AVRTargetLowering::LowerOperation(SDValue Op,
+                                             SelectionDAG &DAG) const {
+  switch (Op.getOpcode()) {
+  case ISD::SHL: // FALLTHROUGH
+  case ISD::SRL:
+  case ISD::SRA:              return LowerShifts(Op, DAG);
+  case ISD::GlobalAddress:    return LowerGlobalAddress(Op, DAG);
+  case ISD::BlockAddress:     return LowerBlockAddress(Op, DAG);
+  /*
+  case ISD::ExternalSymbol:   return LowerExternalSymbol(Op, DAG);
+  case ISD::SETCC:            return LowerSETCC(Op, DAG);
+  */
+  case ISD::BR_CC:            return LowerBR_CC(Op, DAG);
+  /*
+  case ISD::SELECT_CC:        return LowerSELECT_CC(Op, DAG);
+  case ISD::SIGN_EXTEND:      return LowerSIGN_EXTEND(Op, DAG);
+  case ISD::RETURNADDR:       return LowerRETURNADDR(Op, DAG);
+  */
+  case ISD::FRAMEADDR:        return LowerFRAMEADDR(Op, DAG);
+  
+  default:
+    llvm_unreachable("unimplemented operand");
+    return SDValue();
+  }
+
+}
+
+/*
+//===----------------------------------------------------------------------===//
+//                       AVR Inline Assembly Support
+//===----------------------------------------------------------------------===//
+
+/// getConstraintType - Given a constraint letter, return the type of
+/// constraint it is for this target.
+TargetLowering::ConstraintType
+AVRTargetLowering::getConstraintType(const std::string &Constraint) const {
+  if (Constraint.size() == 1) {
+    switch (Constraint[0]) {
+    case 'r':
+      return C_RegisterClass;
+    default:
+      break;
+    }
+  }
+  return TargetLowering::getConstraintType(Constraint);
+}
+
+std::pair<unsigned, const TargetRegisterClass*>
+AVRTargetLowering::
+getRegForInlineAsmConstraint(const std::string &Constraint,
+                             EVT VT) const {
+  if (Constraint.size() == 1) {
+    // GCC Constraint Letters
+    switch (Constraint[0]) {
+    default: break;
+    case 'r':   // GENERAL_REGS
+      if (VT == MVT::i8)
+        return std::make_pair(0U, AVR::GR8RegisterClass);
+
+      return std::make_pair(0U, AVR::GR16RegisterClass);
+    }
+  }
+
+  return TargetLowering::getRegForInlineAsmConstraint(Constraint, VT);
+}
+
+//===----------------------------------------------------------------------===//
+//                      Calling Convention Implementation
+//===----------------------------------------------------------------------===//
+*/
+
+#include "AVRGenCallingConv.inc"
+
+SDValue
+AVRTargetLowering::LowerFormalArguments(SDValue Chain,
+                                           CallingConv::ID CallConv,
+                                           bool isVarArg,
+                                           const SmallVectorImpl<ISD::InputArg>
+                                             &Ins,
+                                           DebugLoc dl,
+                                           SelectionDAG &DAG,
+                                           SmallVectorImpl<SDValue> &InVals)
+                                             const {
+
+  switch (CallConv) {
+  default:
+    llvm_unreachable("Unsupported calling convention");
+  case CallingConv::C:
+  case CallingConv::Fast:
+    return LowerCCCArguments(Chain, CallConv, isVarArg, Ins, dl, DAG, InVals);
+  }
+}
+
+SDValue
+AVRTargetLowering::LowerCall(SDValue Chain, SDValue Callee,
+                                CallingConv::ID CallConv, bool isVarArg,
+                                bool &isTailCall,
+                                const SmallVectorImpl<ISD::OutputArg> &Outs,
+                                const SmallVectorImpl<SDValue> &OutVals,
+                                const SmallVectorImpl<ISD::InputArg> &Ins,
+                                DebugLoc dl, SelectionDAG &DAG,
+                                SmallVectorImpl<SDValue> &InVals) const {
+  // AVR target does not yet support tail call optimization.
+  isTailCall = false;
+
+  switch (CallConv) {
+  default:
+    llvm_unreachable("Unsupported calling convention");
+  case CallingConv::Fast:
+  case CallingConv::C:
+    return LowerCCCCallTo(Chain, Callee, CallConv, isVarArg, isTailCall,
+                          Outs, OutVals, Ins, dl, DAG, InVals);
+  }
+}
+
+/// LowerCCCArguments - transform physical registers into virtual registers and
+/// generate load operations for arguments places on the stack.
+// FIXME: struct return stuff
+// FIXME: varargs
+SDValue
+AVRTargetLowering::LowerCCCArguments(SDValue Chain,
+                                        CallingConv::ID CallConv,
+                                        bool isVarArg,
+                                        const SmallVectorImpl<ISD::InputArg>
+                                          &Ins,
+                                        DebugLoc dl,
+                                        SelectionDAG &DAG,
+                                        SmallVectorImpl<SDValue> &InVals)
+                                          const {
+  MachineFunction &MF = DAG.getMachineFunction();
+  MachineFrameInfo *MFI = MF.getFrameInfo();
+  MachineRegisterInfo &RegInfo = MF.getRegInfo();
+
+  // Assign locations to all of the incoming arguments.
+  SmallVector<CCValAssign, 16> ArgLocs;
+  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(),
+		 getTargetMachine(), ArgLocs, *DAG.getContext());
+  CCInfo.AnalyzeFormalArguments(Ins, CC_AVR);
+
+  assert(!isVarArg && "Varargs not supported yet");
+
+  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
+    CCValAssign &VA = ArgLocs[i];
+    if (VA.isRegLoc()) {
+      // Arguments passed in registers
+      EVT RegVT = VA.getLocVT();
+    } else {
+      // Sanity check
+      assert(VA.isMemLoc());
+      // Load the argument to a virtual register
+      unsigned ObjSize = VA.getLocVT().getSizeInBits()/8;
+      if (ObjSize > 2) {
+        errs() << "LowerFormalArguments Unhandled argument type: "
+             << EVT(VA.getLocVT()).getEVTString()
+             << "\n";
+      }
+      // Create the frame index object for this incoming parameter...
+      int FI = MFI->CreateFixedObject(ObjSize, VA.getLocMemOffset(), true);
+
+      // Create the SelectionDAG nodes corresponding to a load
+      //from this parameter
+      SDValue FIN = DAG.getFrameIndex(FI, MVT::i16);
+      InVals.push_back(DAG.getLoad(VA.getLocVT(), dl, Chain, FIN,
+                                   MachinePointerInfo::getFixedStack(FI),
+                                   false, false, false, 0));
+    }
+  }
+
+  return Chain;
+}
+
+SDValue
+AVRTargetLowering::LowerReturn(SDValue Chain,
+                                  CallingConv::ID CallConv, bool isVarArg,
+                                  const SmallVectorImpl<ISD::OutputArg> &Outs,
+                                  const SmallVectorImpl<SDValue> &OutVals,
+                                  DebugLoc dl, SelectionDAG &DAG) const {
+
+
+  SDValue Flag;
+  return Flag;
+}
+
+/// LowerCCCCallTo - functions arguments are copied from virtual regs to
+/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.
+/// TODO: sret.
+SDValue
+AVRTargetLowering::LowerCCCCallTo(SDValue Chain, SDValue Callee,
+                                     CallingConv::ID CallConv, bool isVarArg,
+                                     bool isTailCall,
+                                     const SmallVectorImpl<ISD::OutputArg>
+                                       &Outs,
+                                     const SmallVectorImpl<SDValue> &OutVals,
+                                     const SmallVectorImpl<ISD::InputArg> &Ins,
+                                     DebugLoc dl, SelectionDAG &DAG,
+                                     SmallVectorImpl<SDValue> &InVals) const {
+  // Analyze operands of the call, assigning locations to each operand.
+  SmallVector<CCValAssign, 16> ArgLocs;
+  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(),
+		 getTargetMachine(), ArgLocs, *DAG.getContext());
+
+  CCInfo.AnalyzeCallOperands(Outs, CC_AVR);
+
+  // Get a count of how many bytes are to be pushed on the stack.
+  unsigned NumBytes = CCInfo.getNextStackOffset();
+
+  Chain = DAG.getCALLSEQ_START(Chain ,DAG.getConstant(NumBytes,
+                                                      getPointerTy(), true));
+
+  SmallVector<std::pair<unsigned, SDValue>, 4> RegsToPass;
+  SmallVector<SDValue, 12> MemOpChains;
+  SDValue StackPtr;
+
+  // Walk the register/memloc assignments, inserting copies/loads.
+  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
+    CCValAssign &VA = ArgLocs[i];
+
+    SDValue Arg = OutVals[i];
+
+    // Promote the value if needed.
+    switch (VA.getLocInfo()) {
+      default: llvm_unreachable("Unknown loc info!");
+      case CCValAssign::Full: break;
+      case CCValAssign::SExt:
+        Arg = DAG.getNode(ISD::SIGN_EXTEND, dl, VA.getLocVT(), Arg);
+        break;
+      case CCValAssign::ZExt:
+        Arg = DAG.getNode(ISD::ZERO_EXTEND, dl, VA.getLocVT(), Arg);
+        break;
+      case CCValAssign::AExt:
+        Arg = DAG.getNode(ISD::ANY_EXTEND, dl, VA.getLocVT(), Arg);
+        break;
+    }
+
+    // Arguments that can be passed on register must be kept at RegsToPass
+    // vector
+    if (VA.isRegLoc()) {
+      RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));
+    } else {
+      assert(VA.isMemLoc());
+
+/*
+      if (StackPtr.getNode() == 0)
+        StackPtr = DAG.getCopyFromReg(Chain, dl, AVR::SPW, getPointerTy());
+*/
+
+      SDValue PtrOff = DAG.getNode(ISD::ADD, dl, getPointerTy(),
+                                   StackPtr,
+                                   DAG.getIntPtrConstant(VA.getLocMemOffset()));
+
+
+      MemOpChains.push_back(DAG.getStore(Chain, dl, Arg, PtrOff,
+                                         MachinePointerInfo(),false, false, 0));
+    }
+  }
+
+  // Transform all store nodes into one single node because all store nodes are
+  // independent of each other.
+  if (!MemOpChains.empty())
+    Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other,
+                        &MemOpChains[0], MemOpChains.size());
+
+  // Build a sequence of copy-to-reg nodes chained together with token chain and
+  // flag operands which copy the outgoing args into registers.  The InFlag in
+  // necessary since all emitted instructions must be stuck together.
+  SDValue InFlag;
+  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i) {
+    Chain = DAG.getCopyToReg(Chain, dl, RegsToPass[i].first,
+                             RegsToPass[i].second, InFlag);
+    InFlag = Chain.getValue(1);
+  }
+
+  // If the callee is a GlobalAddress node (quite common, every direct call is)
+  // turn it into a TargetGlobalAddress node so that legalize doesn't hack it.
+  // Likewise ExternalSymbol -> TargetExternalSymbol.
+  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee))
+    Callee = DAG.getTargetGlobalAddress(G->getGlobal(), dl, MVT::i16);
+  else if (ExternalSymbolSDNode *E = dyn_cast<ExternalSymbolSDNode>(Callee))
+    Callee = DAG.getTargetExternalSymbol(E->getSymbol(), MVT::i16);
+
+  // Returns a chain & a flag for retval copy to use.
+  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);
+  SmallVector<SDValue, 8> Ops;
+  Ops.push_back(Chain);
+  Ops.push_back(Callee);
+
+  // Add argument registers to the end of the list so that they are
+  // known live into the call.
+  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i)
+    Ops.push_back(DAG.getRegister(RegsToPass[i].first,
+                                  RegsToPass[i].second.getValueType()));
+
+  if (InFlag.getNode())
+    Ops.push_back(InFlag);
+
+  Chain = DAG.getNode(AVRISD::CALL, dl, NodeTys, &Ops[0], Ops.size());
+  InFlag = Chain.getValue(1);
+
+  // Create the CALLSEQ_END node.
+  Chain = DAG.getCALLSEQ_END(Chain,
+                             DAG.getConstant(NumBytes, getPointerTy(), true),
+                             DAG.getConstant(0, getPointerTy(), true),
+                             InFlag);
+  InFlag = Chain.getValue(1);
+
+  // Handle result values, copying them out of physregs into vregs that we
+  // return.
+  return LowerCallResult(Chain, InFlag, CallConv, isVarArg, Ins, dl,
+                         DAG, InVals);
+}
+
+/// LowerCallResult - Lower the result values of a call into the
+/// appropriate copies out of appropriate physical registers.
+///
+SDValue
+AVRTargetLowering::LowerCallResult(SDValue Chain, SDValue InFlag,
+                                      CallingConv::ID CallConv, bool isVarArg,
+                                      const SmallVectorImpl<ISD::InputArg> &Ins,
+                                      DebugLoc dl, SelectionDAG &DAG,
+                                      SmallVectorImpl<SDValue> &InVals) const {
+
+  // Assign locations to each value returned by this call.
+  SmallVector<CCValAssign, 16> RVLocs;
+  CCState CCInfo(CallConv, isVarArg, DAG.getMachineFunction(),
+		 getTargetMachine(), RVLocs, *DAG.getContext());
+
+  CCInfo.AnalyzeCallResult(Ins, RetCC_AVR);
+
+  // Copy all of the result registers out of their specified physreg.
+  for (unsigned i = 0; i != RVLocs.size(); ++i) {
+    Chain = DAG.getCopyFromReg(Chain, dl, RVLocs[i].getLocReg(),
+                               RVLocs[i].getValVT(), InFlag).getValue(1);
+    InFlag = Chain.getValue(2);
+    InVals.push_back(Chain.getValue(0));
+  }
+
+  return Chain;
+}
+
+SDValue AVRTargetLowering::LowerShifts(SDValue Op,
+                                          SelectionDAG &DAG) const {
+  unsigned Opc = Op.getOpcode();
+  SDNode* N = Op.getNode();
+  EVT VT = Op.getValueType();
+  DebugLoc dl = N->getDebugLoc();
+
+  // Expand non-constant shifts to loops:
+  if (!isa<ConstantSDNode>(N->getOperand(1)))
+    switch (Opc) {
+    default:
+      assert(0 && "Invalid shift opcode!");
+    case ISD::SHL:
+      return DAG.getNode(AVRISD::SHL, dl,
+                         VT, N->getOperand(0), N->getOperand(1));
+    case ISD::SRA:
+      return DAG.getNode(AVRISD::SRA, dl,
+                         VT, N->getOperand(0), N->getOperand(1));
+    case ISD::SRL:
+      return DAG.getNode(AVRISD::SRL, dl,
+                         VT, N->getOperand(0), N->getOperand(1));
+    }
+
+  uint64_t ShiftAmount = N->getConstantOperandVal(1);
+
+  // Expand the stuff into sequence of shifts.
+  // FIXME: for some shift amounts this might be done better!
+  // E.g.: foo >> (8 + N) => sxt(swpb(foo)) >> N
+  SDValue Victim = N->getOperand(0);
+
+  unsigned int TargetOpcode = 0;
+  switch(Opc) {
+    case ISD::SHL: TargetOpcode = AVRISD::SHLC; break;
+    case ISD::SRA: TargetOpcode = AVRISD::SRAC; break;
+    case ISD::SRL: TargetOpcode = AVRISD::SRLC; break;
+  }
+
+  while (ShiftAmount--)
+    Victim = DAG.getNode(TargetOpcode, dl, VT, Victim);
+
+  return Victim;
+}
+
+SDValue AVRTargetLowering::LowerGlobalAddress(SDValue Op,
+                                                 SelectionDAG &DAG) const {
+  const GlobalValue *GV = cast<GlobalAddressSDNode>(Op)->getGlobal();
+  int64_t Offset = cast<GlobalAddressSDNode>(Op)->getOffset();
+
+  // Create the TargetGlobalAddress node, folding in the constant offset.
+  SDValue Result = DAG.getTargetGlobalAddress(GV, Op.getDebugLoc(),
+                                              getPointerTy(), Offset);
+  return DAG.getNode(AVRISD::Wrapper, Op.getDebugLoc(),
+                     getPointerTy(), Result);
+}
+
+/*
+SDValue AVRTargetLowering::LowerExternalSymbol(SDValue Op,
+                                                  SelectionDAG &DAG) const {
+  DebugLoc dl = Op.getDebugLoc();
+  const char *Sym = cast<ExternalSymbolSDNode>(Op)->getSymbol();
+  SDValue Result = DAG.getTargetExternalSymbol(Sym, getPointerTy());
+
+  return DAG.getNode(AVRISD::Wrapper, dl, getPointerTy(), Result);;
+}
+
+*/
+
+SDValue AVRTargetLowering::LowerBlockAddress(SDValue Op,
+                                                SelectionDAG &DAG) const {
+  DebugLoc dl = Op.getDebugLoc();
+  const BlockAddress *BA = cast<BlockAddressSDNode>(Op)->getBlockAddress();
+  SDValue Result = DAG.getBlockAddress(BA, getPointerTy(), /*isTarget=*/true);
+
+  return DAG.getNode(AVRISD::Wrapper, dl, getPointerTy(), Result);;
+}
+static SDValue EmitCMP(SDValue &LHS, SDValue &RHS, SDValue &TargetCC,
+                       ISD::CondCode CC,
+                       DebugLoc dl, SelectionDAG &DAG) {
+  // FIXME: Handle bittests someday
+  assert(!LHS.getValueType().isFloatingPoint() && "We don't handle FP yet");
+
+  // FIXME: Handle jump negative someday
+  AVRCC::CondCodes TCC = AVRCC::COND_INVALID;
+  switch (CC) {
+  default: llvm_unreachable("Invalid integer condition!");
+  case ISD::SETEQ:
+    TCC = AVRCC::COND_E;     // aka COND_Z
+    // Minor optimization: if LHS is a constant, swap operands, then the
+    // constant can be folded into comparison.
+    if (LHS.getOpcode() == ISD::Constant)
+      std::swap(LHS, RHS);
+    break;
+  case ISD::SETNE:
+    TCC = AVRCC::COND_NE;    // aka COND_NZ
+    // Minor optimization: if LHS is a constant, swap operands, then the
+    // constant can be folded into comparison.
+    if (LHS.getOpcode() == ISD::Constant)
+      std::swap(LHS, RHS);
+    break;
+  case ISD::SETULE:
+    std::swap(LHS, RHS);        // FALLTHROUGH
+  case ISD::SETUGE:
+    // Turn lhs u>= rhs with lhs constant into rhs u< lhs+1, this allows us to
+    // fold constant into instruction.
+    if (const ConstantSDNode * C = dyn_cast<ConstantSDNode>(LHS)) {
+      LHS = RHS;
+      RHS = DAG.getConstant(C->getSExtValue() + 1, C->getValueType(0));
+      TCC = AVRCC::COND_LO;
+      break;
+    }
+    TCC = AVRCC::COND_HS;    // aka COND_C
+    break;
+  case ISD::SETUGT:
+    std::swap(LHS, RHS);        // FALLTHROUGH
+  case ISD::SETULT:
+    // Turn lhs u< rhs with lhs constant into rhs u>= lhs+1, this allows us to
+    // fold constant into instruction.
+    if (const ConstantSDNode * C = dyn_cast<ConstantSDNode>(LHS)) {
+      LHS = RHS;
+      RHS = DAG.getConstant(C->getSExtValue() + 1, C->getValueType(0));
+      TCC = AVRCC::COND_HS;
+      break;
+    }
+    TCC = AVRCC::COND_LO;    // aka COND_NC
+    break;
+  case ISD::SETLE:
+    std::swap(LHS, RHS);        // FALLTHROUGH
+  case ISD::SETGE:
+    // Turn lhs >= rhs with lhs constant into rhs < lhs+1, this allows us to
+    // fold constant into instruction.
+    if (const ConstantSDNode * C = dyn_cast<ConstantSDNode>(LHS)) {
+      LHS = RHS;
+      RHS = DAG.getConstant(C->getSExtValue() + 1, C->getValueType(0));
+      TCC = AVRCC::COND_L;
+      break;
+    }
+    TCC = AVRCC::COND_GE;
+    break;
+  case ISD::SETGT:
+    std::swap(LHS, RHS);        // FALLTHROUGH
+  case ISD::SETLT:
+    // Turn lhs < rhs with lhs constant into rhs >= lhs+1, this allows us to
+    // fold constant into instruction.
+    if (const ConstantSDNode * C = dyn_cast<ConstantSDNode>(LHS)) {
+      LHS = RHS;
+      RHS = DAG.getConstant(C->getSExtValue() + 1, C->getValueType(0));
+      TCC = AVRCC::COND_GE;
+      break;
+    }
+    TCC = AVRCC::COND_L;
+    break;
+  }
+
+  TargetCC = DAG.getConstant(TCC, MVT::i8);
+  return DAG.getNode(AVRISD::CMP, dl, MVT::Glue, LHS, RHS);
+}
+
+
+SDValue AVRTargetLowering::LowerBR_CC(SDValue Op, SelectionDAG &DAG) const {
+  SDValue Chain = Op.getOperand(0);
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(1))->get();
+  SDValue LHS   = Op.getOperand(2);
+  SDValue RHS   = Op.getOperand(3);
+  SDValue Dest  = Op.getOperand(4);
+  DebugLoc dl   = Op.getDebugLoc();
+
+  SDValue TargetCC;
+  SDValue Flag = EmitCMP(LHS, RHS, TargetCC, CC, dl, DAG);
+
+  return DAG.getNode(AVRISD::BR_CC, dl, Op.getValueType(),
+                     Chain, Dest, TargetCC, Flag);
+}
+
+/*
+SDValue AVRTargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
+  SDValue LHS   = Op.getOperand(0);
+  SDValue RHS   = Op.getOperand(1);
+  DebugLoc dl   = Op.getDebugLoc();
+
+  // If we are doing an AND and testing against zero, then the CMP
+  // will not be generated.  The AND (or BIT) will generate the condition codes,
+  // but they are different from CMP.
+  // FIXME: since we're doing a post-processing, use a pseudoinstr here, so
+  // lowering & isel wouldn't diverge.
+  bool andCC = false;
+  if (ConstantSDNode *RHSC = dyn_cast<ConstantSDNode>(RHS)) {
+    if (RHSC->isNullValue() && LHS.hasOneUse() &&
+        (LHS.getOpcode() == ISD::AND ||
+         (LHS.getOpcode() == ISD::TRUNCATE &&
+          LHS.getOperand(0).getOpcode() == ISD::AND))) {
+      andCC = true;
+    }
+  }
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(2))->get();
+  SDValue TargetCC;
+  SDValue Flag = EmitCMP(LHS, RHS, TargetCC, CC, dl, DAG);
+
+  // Get the condition codes directly from the status register, if its easy.
+  // Otherwise a branch will be generated.  Note that the AND and BIT
+  // instructions generate different flags than CMP, the carry bit can be used
+  // for NE/EQ.
+  bool Invert = false;
+  bool Shift = false;
+  bool Convert = true;
+  switch (cast<ConstantSDNode>(TargetCC)->getZExtValue()) {
+   default:
+    Convert = false;
+    break;
+   case AVRCC::COND_HS:
+     // Res = SRW & 1, no processing is required
+     break;
+   case AVRCC::COND_LO:
+     // Res = ~(SRW & 1)
+     Invert = true;
+     break;
+   case AVRCC::COND_NE:
+     if (andCC) {
+       // C = ~Z, thus Res = SRW & 1, no processing is required
+     } else {
+       // Res = ~((SRW >> 1) & 1)
+       Shift = true;
+       Invert = true;
+     }
+     break;
+   case AVRCC::COND_E:
+     Shift = true;
+     // C = ~Z for AND instruction, thus we can put Res = ~(SRW & 1), however,
+     // Res = (SRW >> 1) & 1 is 1 word shorter.
+     break;
+  }
+  EVT VT = Op.getValueType();
+  SDValue One  = DAG.getConstant(1, VT);
+  if (Convert) {
+    SDValue SR = DAG.getCopyFromReg(DAG.getEntryNode(), dl, AVR::SRW,
+                                    MVT::i16, Flag);
+    if (Shift)
+      // FIXME: somewhere this is turned into a SRL, lower it MSP specific?
+      SR = DAG.getNode(ISD::SRA, dl, MVT::i16, SR, One);
+    SR = DAG.getNode(ISD::AND, dl, MVT::i16, SR, One);
+    if (Invert)
+      SR = DAG.getNode(ISD::XOR, dl, MVT::i16, SR, One);
+    return SR;
+  } else {
+    SDValue Zero = DAG.getConstant(0, VT);
+    SDVTList VTs = DAG.getVTList(Op.getValueType(), MVT::Glue);
+    SmallVector<SDValue, 4> Ops;
+    Ops.push_back(One);
+    Ops.push_back(Zero);
+    Ops.push_back(TargetCC);
+    Ops.push_back(Flag);
+    return DAG.getNode(AVRISD::SELECT_CC, dl, VTs, &Ops[0], Ops.size());
+  }
+}
+
+SDValue AVRTargetLowering::LowerSELECT_CC(SDValue Op,
+                                             SelectionDAG &DAG) const {
+  SDValue LHS    = Op.getOperand(0);
+  SDValue RHS    = Op.getOperand(1);
+  SDValue TrueV  = Op.getOperand(2);
+  SDValue FalseV = Op.getOperand(3);
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
+  DebugLoc dl    = Op.getDebugLoc();
+
+  SDValue TargetCC;
+  SDValue Flag = EmitCMP(LHS, RHS, TargetCC, CC, dl, DAG);
+
+  SDVTList VTs = DAG.getVTList(Op.getValueType(), MVT::Glue);
+  SmallVector<SDValue, 4> Ops;
+  Ops.push_back(TrueV);
+  Ops.push_back(FalseV);
+  Ops.push_back(TargetCC);
+  Ops.push_back(Flag);
+
+  return DAG.getNode(AVRISD::SELECT_CC, dl, VTs, &Ops[0], Ops.size());
+}
+
+SDValue AVRTargetLowering::LowerSIGN_EXTEND(SDValue Op,
+                                               SelectionDAG &DAG) const {
+  SDValue Val = Op.getOperand(0);
+  EVT VT      = Op.getValueType();
+  DebugLoc dl = Op.getDebugLoc();
+
+  assert(VT == MVT::i16 && "Only support i16 for now!");
+
+  return DAG.getNode(ISD::SIGN_EXTEND_INREG, dl, VT,
+                     DAG.getNode(ISD::ANY_EXTEND, dl, VT, Val),
+                     DAG.getValueType(Val.getValueType()));
+}
+
+SDValue
+AVRTargetLowering::getReturnAddressFrameIndex(SelectionDAG &DAG) const {
+  MachineFunction &MF = DAG.getMachineFunction();
+  AVRMachineFunctionInfo *FuncInfo = MF.getInfo<AVRMachineFunctionInfo>();
+  int ReturnAddrIndex = FuncInfo->getRAIndex();
+
+  if (ReturnAddrIndex == 0) {
+    // Set up a frame object for the return address.
+    uint64_t SlotSize = TD->getPointerSize();
+    ReturnAddrIndex = MF.getFrameInfo()->CreateFixedObject(SlotSize, -SlotSize,
+                                                           true);
+    FuncInfo->setRAIndex(ReturnAddrIndex);
+  }
+
+  return DAG.getFrameIndex(ReturnAddrIndex, getPointerTy());
+}
+
+SDValue AVRTargetLowering::LowerRETURNADDR(SDValue Op,
+                                              SelectionDAG &DAG) const {
+  MachineFrameInfo *MFI = DAG.getMachineFunction().getFrameInfo();
+  MFI->setReturnAddressIsTaken(true);
+
+  unsigned Depth = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
+  DebugLoc dl = Op.getDebugLoc();
+
+  if (Depth > 0) {
+    SDValue FrameAddr = LowerFRAMEADDR(Op, DAG);
+    SDValue Offset =
+      DAG.getConstant(TD->getPointerSize(), MVT::i16);
+    return DAG.getLoad(getPointerTy(), dl, DAG.getEntryNode(),
+                       DAG.getNode(ISD::ADD, dl, getPointerTy(),
+                                   FrameAddr, Offset),
+                       MachinePointerInfo(), false, false, false, 0);
+  }
+
+  // Just load the return address.
+  SDValue RetAddrFI = getReturnAddressFrameIndex(DAG);
+  return DAG.getLoad(getPointerTy(), dl, DAG.getEntryNode(),
+                     RetAddrFI, MachinePointerInfo(), false, false, false, 0);
+}
+
+*/
+SDValue AVRTargetLowering::LowerFRAMEADDR(SDValue Op,
+                                             SelectionDAG &DAG) const {
+  MachineFrameInfo *MFI = DAG.getMachineFunction().getFrameInfo();
+  MFI->setFrameAddressIsTaken(true);
+
+  EVT VT = Op.getValueType();
+  DebugLoc dl = Op.getDebugLoc();  // FIXME probably not meaningful
+  unsigned Depth = cast<ConstantSDNode>(Op.getOperand(0))->getZExtValue();
+  SDValue FrameAddr = DAG.getCopyFromReg(DAG.getEntryNode(), dl,
+                                         AVR::Y, VT);
+  while (Depth--)
+    FrameAddr = DAG.getLoad(VT, dl, DAG.getEntryNode(), FrameAddr,
+                            MachinePointerInfo(),
+                            false, false, false, 0);
+  return FrameAddr;
+}
+
+/*
+/// getPostIndexedAddressParts - returns true by value, base pointer and
+/// offset pointer and addressing mode by reference if this node can be
+/// combined with a load / store to form a post-indexed load / store.
+bool AVRTargetLowering::getPostIndexedAddressParts(SDNode *N, SDNode *Op,
+                                                      SDValue &Base,
+                                                      SDValue &Offset,
+                                                      ISD::MemIndexedMode &AM,
+                                                      SelectionDAG &DAG) const {
+
+  LoadSDNode *LD = cast<LoadSDNode>(N);
+  if (LD->getExtensionType() != ISD::NON_EXTLOAD)
+    return false;
+
+  EVT VT = LD->getMemoryVT();
+  if (VT != MVT::i8 && VT != MVT::i16)
+    return false;
+
+  if (Op->getOpcode() != ISD::ADD)
+    return false;
+
+  if (ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(Op->getOperand(1))) {
+    uint64_t RHSC = RHS->getZExtValue();
+    if ((VT == MVT::i16 && RHSC != 2) ||
+        (VT == MVT::i8 && RHSC != 1))
+      return false;
+
+    Base = Op->getOperand(0);
+    Offset = DAG.getConstant(RHSC, VT);
+    AM = ISD::POST_INC;
+    return true;
+  }
+
+  return false;
+}
+*/
+
+const char *AVRTargetLowering::getTargetNodeName(unsigned Opcode) const {
+  switch (Opcode) {
+  default: return NULL;
+  case AVRISD::RET_FLAG:           return "AVRISD::RET_FLAG";
+  case AVRISD::RETI_FLAG:          return "AVRISD::RETI_FLAG";
+  case AVRISD::RLC:                return "AVRISD::RLC";
+  case AVRISD::RRC:                return "AVRISD::RRC";
+  case AVRISD::CALL:               return "AVRISD::CALL";
+  case AVRISD::Wrapper:            return "AVRISD::Wrapper";
+  case AVRISD::BR_CC:              return "AVRISD::BR_CC";
+  case AVRISD::CMP:                return "AVRISD::CMP";
+  case AVRISD::SELECT_CC:          return "AVRISD::SELECT_CC";
+  case AVRISD::SHL:                return "AVRISD::SHL";
+  case AVRISD::SRL:                return "AVRISD::SRL";
+  }
+}
+
+bool AVRTargetLowering::isTruncateFree(Type *Ty1,
+                                          Type *Ty2) const {
+  if (!Ty1->isIntegerTy() || !Ty2->isIntegerTy())
+    return false;
+
+  return (Ty1->getPrimitiveSizeInBits() > Ty2->getPrimitiveSizeInBits());
+}
+
+bool AVRTargetLowering::isTruncateFree(EVT VT1, EVT VT2) const {
+  if (!VT1.isInteger() || !VT2.isInteger())
+    return false;
+
+  return (VT1.getSizeInBits() > VT2.getSizeInBits());
+}
+
+bool AVRTargetLowering::isZExtFree(Type *Ty1, Type *Ty2) const {
+  // AVR implicitly zero-extends 8-bit results in 16-bit registers.
+  return 0 && Ty1->isIntegerTy(8) && Ty2->isIntegerTy(16);
+}
+
+bool AVRTargetLowering::isZExtFree(EVT VT1, EVT VT2) const {
+  // AVR implicitly zero-extends 8-bit results in 16-bit registers.
+  return 0 && VT1 == MVT::i8 && VT2 == MVT::i16;
+}
+
+
+MachineBasicBlock*
+AVRTargetLowering::EmitShiftInstr(MachineInstr *MI,
+                                     MachineBasicBlock *BB) const {
+  MachineFunction *F = BB->getParent();
+  MachineRegisterInfo &RI = F->getRegInfo();
+  DebugLoc dl = MI->getDebugLoc();
+  const TargetInstrInfo &TII = *getTargetMachine().getInstrInfo();
+
+  const BasicBlock *LLVM_BB = BB->getBasicBlock();
+  MachineFunction::iterator I = BB;
+  ++I;
+
+  // Create loop block
+  MachineBasicBlock *LoopBB = F->CreateMachineBasicBlock(LLVM_BB);
+  MachineBasicBlock *RemBB  = F->CreateMachineBasicBlock(LLVM_BB);
+
+  F->insert(I, LoopBB);
+  F->insert(I, RemBB);
+
+  // Update machine-CFG edges by transferring all successors of the current
+  // block to the block containing instructions after shift.
+  RemBB->splice(RemBB->begin(), BB,
+                llvm::next(MachineBasicBlock::iterator(MI)),
+                BB->end());
+  RemBB->transferSuccessorsAndUpdatePHIs(BB);
+
+  // Add adges BB => LoopBB => RemBB, BB => RemBB, LoopBB => LoopBB
+  BB->addSuccessor(LoopBB);
+  BB->addSuccessor(RemBB);
+  LoopBB->addSuccessor(RemBB);
+  LoopBB->addSuccessor(LoopBB);
+
+  return RemBB;
+}
+
+MachineBasicBlock*
+AVRTargetLowering::EmitInstrWithCustomInserter(MachineInstr *MI,
+                                                  MachineBasicBlock *BB) const {
+  unsigned Opc = MI->getOpcode();
+
+  if (Opc == AVR::Shl8 || Opc == AVR::Sra8 ||
+      Opc == AVR::Srl8)
+    return EmitShiftInstr(MI, BB);
+
+}
Index: lib/Target/AVR/AVRISelLowering.h
===================================================================
--- lib/Target/AVR/AVRISelLowering.h	(revision 0)
+++ lib/Target/AVR/AVRISelLowering.h	(revision 0)
@@ -0,0 +1,184 @@
+//==-- AVRISelLowering.h - AVR DAG Lowering Interface ------*- C++ -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interfaces that AVR uses to lower LLVM code into a
+// selection DAG.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TARGET_AVR_ISELLOWERING_H
+#define LLVM_TARGET_AVR_ISELLOWERING_H
+
+#include "AVR.h"
+#include "llvm/CodeGen/SelectionDAG.h"
+#include "llvm/Target/TargetLowering.h"
+
+namespace llvm {
+  namespace AVRISD {
+    enum {
+      FIRST_NUMBER = ISD::BUILTIN_OP_END,
+
+      /// Return with a flag operand. Operand 0 is the chain operand.
+      RET_FLAG,
+
+      /// Same as RET_FLAG, but used for returning from ISRs.
+      RETI_FLAG,
+
+      /// Y = RLC, RRC X, rotate left/right via carry
+      RLC, RRC,
+
+      /// CALL - These operations represent an abstract call
+      /// instruction, which includes a bunch of information.
+      CALL,
+
+      /// Wrapper - A wrapper node for TargetConstantPool, TargetExternalSymbol,
+      /// and TargetGlobalAddress.
+      Wrapper,
+
+      /// CMP - Compare instruction.
+      CMP,
+
+      /// SetCC - Operand 0 is condition code, and operand 1 is the flag
+      /// operand produced by a CMP instruction.
+      SETCC,
+
+      /// AVR conditional branches. Operand 0 is the chain operand, operand 1
+      /// is the block to branch if condition is true, operand 2 is the
+      /// condition code, and operand 3 is the flag operand produced by a CMP
+      /// instruction.
+      BR_CC,
+
+      /// SELECT_CC - Operand 0 and operand 1 are selection variable, operand 3
+      /// is condition code and operand 4 is flag operand.
+      SELECT_CC,
+
+      /// SHLC, SRAC, SRLC - constant shifts.
+      SHLC, SRAC, SRLC,
+
+      /// SHL, SRA, SRL - non-constant shifts
+      SHL, SRA, SRL
+    };
+  }
+
+  class AVRTargetMachine;
+
+  class AVRTargetLowering : public TargetLowering {
+  public:
+    explicit AVRTargetLowering(AVRTargetMachine &TM);
+
+    //virtual MVT getShiftAmountTy(EVT LHSTy) const { return MVT::i8; }
+
+    /// LowerOperation - Provide custom lowering hooks for some operations.
+    virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;
+
+    /// getTargetNodeName - This method returns the name of a target specific
+    /// DAG node.
+    virtual const char *getTargetNodeName(unsigned Opcode) const;
+
+    SDValue LowerShifts(SDValue Op, SelectionDAG &DAG) const;
+
+    SDValue LowerGlobalAddress(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerBlockAddress(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerExternalSymbol(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerBR_CC(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerSETCC(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerSELECT_CC(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerSIGN_EXTEND(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerRETURNADDR(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerFRAMEADDR(SDValue Op, SelectionDAG &DAG) const;
+    SDValue getReturnAddressFrameIndex(SelectionDAG &DAG) const;
+
+/*
+    TargetLowering::ConstraintType
+    getConstraintType(const std::string &Constraint) const;
+    std::pair<unsigned, const TargetRegisterClass*>
+    getRegForInlineAsmConstraint(const std::string &Constraint, EVT VT) const;
+*/
+
+    /// isTruncateFree - Return true if it's free to truncate a value of type
+    /// Ty1 to type Ty2. e.g. On msp430 it's free to truncate a i16 value in
+    /// register R15W to i8 by referencing its sub-register R15B.
+    virtual bool isTruncateFree(Type *Ty1, Type *Ty2) const;
+    virtual bool isTruncateFree(EVT VT1, EVT VT2) const;
+
+    /// isZExtFree - Return true if any actual instruction that defines a value
+    /// of type Ty1 implicit zero-extends the value to Ty2 in the result
+    /// register. This does not necessarily include registers defined in unknown
+    /// ways, such as incoming arguments, or copies from unknown virtual
+    /// registers. Also, if isTruncateFree(Ty2, Ty1) is true, this does not
+    /// necessarily apply to truncate instructions. e.g. on msp430, all
+    /// instructions that define 8-bit values implicit zero-extend the result
+    /// out to 16 bits.
+    virtual bool isZExtFree(Type *Ty1, Type *Ty2) const;
+    virtual bool isZExtFree(EVT VT1, EVT VT2) const;
+
+    MachineBasicBlock* EmitInstrWithCustomInserter(MachineInstr *MI,
+                                                   MachineBasicBlock *BB) const;
+    MachineBasicBlock* EmitShiftInstr(MachineInstr *MI,
+                                      MachineBasicBlock *BB) const;
+
+  private:
+    SDValue LowerCCCCallTo(SDValue Chain, SDValue Callee,
+                           CallingConv::ID CallConv, bool isVarArg,
+                           bool isTailCall,
+                           const SmallVectorImpl<ISD::OutputArg> &Outs,
+                           const SmallVectorImpl<SDValue> &OutVals,
+                           const SmallVectorImpl<ISD::InputArg> &Ins,
+                           DebugLoc dl, SelectionDAG &DAG,
+                           SmallVectorImpl<SDValue> &InVals) const;
+
+    SDValue LowerCCCArguments(SDValue Chain,
+                              CallingConv::ID CallConv,
+                              bool isVarArg,
+                              const SmallVectorImpl<ISD::InputArg> &Ins,
+                              DebugLoc dl,
+                              SelectionDAG &DAG,
+                              SmallVectorImpl<SDValue> &InVals) const;
+
+    SDValue LowerCallResult(SDValue Chain, SDValue InFlag,
+                            CallingConv::ID CallConv, bool isVarArg,
+                            const SmallVectorImpl<ISD::InputArg> &Ins,
+                            DebugLoc dl, SelectionDAG &DAG,
+                            SmallVectorImpl<SDValue> &InVals) const;
+
+    virtual SDValue
+      LowerFormalArguments(SDValue Chain,
+                           CallingConv::ID CallConv, bool isVarArg,
+                           const SmallVectorImpl<ISD::InputArg> &Ins,
+                           DebugLoc dl, SelectionDAG &DAG,
+                           SmallVectorImpl<SDValue> &InVals) const;
+    virtual SDValue
+      LowerCall(SDValue Chain, SDValue Callee,
+                CallingConv::ID CallConv, bool isVarArg, bool &isTailCall,
+                const SmallVectorImpl<ISD::OutputArg> &Outs,
+                const SmallVectorImpl<SDValue> &OutVals,
+                const SmallVectorImpl<ISD::InputArg> &Ins,
+                DebugLoc dl, SelectionDAG &DAG,
+                SmallVectorImpl<SDValue> &InVals) const;
+
+    virtual SDValue
+      LowerReturn(SDValue Chain,
+                  CallingConv::ID CallConv, bool isVarArg,
+                  const SmallVectorImpl<ISD::OutputArg> &Outs,
+                  const SmallVectorImpl<SDValue> &OutVals,
+                  DebugLoc dl, SelectionDAG &DAG) const;
+
+/*
+    virtual bool getPostIndexedAddressParts(SDNode *N, SDNode *Op,
+                                            SDValue &Base,
+                                            SDValue &Offset,
+                                            ISD::MemIndexedMode &AM,
+                                            SelectionDAG &DAG) const;
+*/
+
+    const AVRTargetMachine &TM;
+  };
+} // namespace llvm
+
+#endif // LLVM_TARGET_AVR_ISELLOWERING_H
Index: lib/Target/AVR/AVRMachineFunctionInfo.cpp
===================================================================
--- lib/Target/AVR/AVRMachineFunctionInfo.cpp	(revision 0)
+++ lib/Target/AVR/AVRMachineFunctionInfo.cpp	(revision 0)
@@ -0,0 +1,14 @@
+//==- AVRMachineFuctionInfo.cpp - AVR machine function info -*- C++ -*-=//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVRMachineFunctionInfo.h"
+
+using namespace llvm;
+
+void AVRMachineFunctionInfo::anchor() { }
Index: lib/Target/AVR/AVRMCInstLower.cpp
===================================================================
--- lib/Target/AVR/AVRMCInstLower.cpp	(revision 0)
+++ lib/Target/AVR/AVRMCInstLower.cpp	(revision 0)
@@ -0,0 +1,150 @@
+//===-- AVRMCInstLower.cpp - Convert AVR MachineInstr to an MCInst---===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains code to lower AVR MachineInstrs to their corresponding
+// MCInst records.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVRMCInstLower.h"
+#include "llvm/CodeGen/AsmPrinter.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/Target/Mangler.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/ADT/SmallString.h"
+using namespace llvm;
+
+MCSymbol *AVRMCInstLower::
+GetGlobalAddressSymbol(const MachineOperand &MO) const {
+  switch (MO.getTargetFlags()) {
+  default: llvm_unreachable("Unknown target flag on GV operand");
+  case 0: break;
+  }
+
+  return Printer.Mang->getSymbol(MO.getGlobal());
+}
+
+MCSymbol *AVRMCInstLower::
+GetExternalSymbolSymbol(const MachineOperand &MO) const {
+  switch (MO.getTargetFlags()) {
+  default: assert(0 && "Unknown target flag on GV operand");
+  case 0: break;
+  }
+
+  return Printer.GetExternalSymbolSymbol(MO.getSymbolName());
+}
+
+MCSymbol *AVRMCInstLower::
+GetJumpTableSymbol(const MachineOperand &MO) const {
+  SmallString<256> Name;
+  raw_svector_ostream(Name) << Printer.MAI->getPrivateGlobalPrefix() << "JTI"
+                            << Printer.getFunctionNumber() << '_'
+                            << MO.getIndex();
+
+  switch (MO.getTargetFlags()) {
+  default: llvm_unreachable("Unknown target flag on GV operand");
+  case 0: break;
+  }
+
+  // Create a symbol for the name.
+  return Ctx.GetOrCreateSymbol(Name.str());
+}
+
+MCSymbol *AVRMCInstLower::
+GetConstantPoolIndexSymbol(const MachineOperand &MO) const {
+  SmallString<256> Name;
+  raw_svector_ostream(Name) << Printer.MAI->getPrivateGlobalPrefix() << "CPI"
+                            << Printer.getFunctionNumber() << '_'
+                            << MO.getIndex();
+
+  switch (MO.getTargetFlags()) {
+  default: llvm_unreachable("Unknown target flag on GV operand");
+  case 0: break;
+  }
+
+  // Create a symbol for the name.
+  return Ctx.GetOrCreateSymbol(Name.str());
+}
+
+MCSymbol *AVRMCInstLower::
+GetBlockAddressSymbol(const MachineOperand &MO) const {
+  switch (MO.getTargetFlags()) {
+  default: assert(0 && "Unknown target flag on GV operand");
+  case 0: break;
+  }
+
+  return Printer.GetBlockAddressSymbol(MO.getBlockAddress());
+}
+
+MCOperand AVRMCInstLower::
+LowerSymbolOperand(const MachineOperand &MO, MCSymbol *Sym) const {
+  // FIXME: We would like an efficient form for this, so we don't have to do a
+  // lot of extra uniquing.
+  const MCExpr *Expr = MCSymbolRefExpr::Create(Sym, Ctx);
+
+  switch (MO.getTargetFlags()) {
+  default: llvm_unreachable("Unknown target flag on GV operand");
+  case 0: break;
+  }
+
+  if (!MO.isJTI() && MO.getOffset())
+    Expr = MCBinaryExpr::CreateAdd(Expr,
+                                   MCConstantExpr::Create(MO.getOffset(), Ctx),
+                                   Ctx);
+  return MCOperand::CreateExpr(Expr);
+}
+
+void AVRMCInstLower::Lower(const MachineInstr *MI, MCInst &OutMI) const {
+  OutMI.setOpcode(MI->getOpcode());
+
+  for (unsigned i = 0, e = MI->getNumOperands(); i != e; ++i) {
+    const MachineOperand &MO = MI->getOperand(i);
+
+    MCOperand MCOp;
+    switch (MO.getType()) {
+    default:
+      MI->dump();
+      assert(0 && "unknown operand type");
+    case MachineOperand::MO_Register:
+      // Ignore all implicit register operands.
+      if (MO.isImplicit()) continue;
+      MCOp = MCOperand::CreateReg(MO.getReg());
+      break;
+    case MachineOperand::MO_Immediate:
+      MCOp = MCOperand::CreateImm(MO.getImm());
+      break;
+    case MachineOperand::MO_MachineBasicBlock:
+      MCOp = MCOperand::CreateExpr(MCSymbolRefExpr::Create(
+                         MO.getMBB()->getSymbol(), Ctx));
+      break;
+    case MachineOperand::MO_GlobalAddress:
+      MCOp = LowerSymbolOperand(MO, GetGlobalAddressSymbol(MO));
+      break;
+    case MachineOperand::MO_ExternalSymbol:
+      MCOp = LowerSymbolOperand(MO, GetExternalSymbolSymbol(MO));
+      break;
+    case MachineOperand::MO_JumpTableIndex:
+      MCOp = LowerSymbolOperand(MO, GetJumpTableSymbol(MO));
+      break;
+    case MachineOperand::MO_ConstantPoolIndex:
+      MCOp = LowerSymbolOperand(MO, GetConstantPoolIndexSymbol(MO));
+      break;
+    case MachineOperand::MO_BlockAddress:
+      MCOp = LowerSymbolOperand(MO, GetBlockAddressSymbol(MO));
+    }
+
+    OutMI.addOperand(MCOp);
+  }
+}
Index: lib/Target/AVR/AVRMCInstLower.h
===================================================================
--- lib/Target/AVR/AVRMCInstLower.h	(revision 0)
+++ lib/Target/AVR/AVRMCInstLower.h	(revision 0)
@@ -0,0 +1,50 @@
+//===-- AVRMCInstLower.h - Lower MachineInstr to MCInst ----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef AVR_MCINSTLOWER_H
+#define AVR_MCINSTLOWER_H
+
+#include "llvm/Support/Compiler.h"
+
+namespace llvm {
+  class AsmPrinter;
+  class MCAsmInfo;
+  class MCContext;
+  class MCInst;
+  class MCOperand;
+  class MCSymbol;
+  class MachineInstr;
+  class MachineModuleInfoMachO;
+  class MachineOperand;
+  class Mangler;
+
+  /// AVRMCInstLower - This class is used to lower an MachineInstr
+  /// into an MCInst.
+class LLVM_LIBRARY_VISIBILITY AVRMCInstLower {
+  MCContext &Ctx;
+  Mangler &Mang;
+
+  AsmPrinter &Printer;
+public:
+  AVRMCInstLower(MCContext &ctx, Mangler &mang, AsmPrinter &printer)
+    : Ctx(ctx), Mang(mang), Printer(printer) {}
+  void Lower(const MachineInstr *MI, MCInst &OutMI) const;
+
+  MCOperand LowerSymbolOperand(const MachineOperand &MO, MCSymbol *Sym) const;
+
+  MCSymbol *GetGlobalAddressSymbol(const MachineOperand &MO) const;
+  MCSymbol *GetExternalSymbolSymbol(const MachineOperand &MO) const;
+  MCSymbol *GetJumpTableSymbol(const MachineOperand &MO) const;
+  MCSymbol *GetConstantPoolIndexSymbol(const MachineOperand &MO) const;
+  MCSymbol *GetBlockAddressSymbol(const MachineOperand &MO) const;
+};
+
+}
+
+#endif
Index: lib/Target/AVR/AVRRegisterInfo.cpp
===================================================================
--- lib/Target/AVR/AVRRegisterInfo.cpp	(revision 0)
+++ lib/Target/AVR/AVRRegisterInfo.cpp	(revision 0)
@@ -0,0 +1,183 @@
+//===- AVRRegisterInfo.cpp - AVR Register Information ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the AVR implementation of the TargetRegisterInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "avr-reg-info"
+
+#include "AVR.h"
+#include "AVRMachineFunctionInfo.h"
+#include "AVRRegisterInfo.h"
+#include "AVRTargetMachine.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetOptions.h"
+#include "llvm/ADT/BitVector.h"
+#include "llvm/Support/ErrorHandling.h"
+
+#define GET_REGINFO_TARGET_DESC
+#include "AVRGenRegisterInfo.inc"
+
+using namespace llvm;
+
+// FIXME: Provide proper call frame setup / destroy opcodes.
+AVRRegisterInfo::AVRRegisterInfo(AVRTargetMachine &tm,
+                                       const TargetInstrInfo &tii)
+  : AVRGenRegisterInfo(AVR::PC), TM(tm), TII(tii) {
+}
+
+const MCPhysReg*
+AVRRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
+	return 0;
+}
+
+BitVector AVRRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
+  BitVector Reserved(getNumRegs());
+  const TargetFrameLowering *TFI = MF.getTarget().getFrameLowering();
+
+  if (TFI->hasFP(MF))
+    Reserved.set(AVR::Y);
+
+  return Reserved;
+}
+
+const TargetRegisterClass *
+AVRRegisterInfo::getPointerRegClass(unsigned Kind) const {
+  return &AVR::GR16RegClass;
+}
+
+void AVRRegisterInfo::
+eliminateCallFramePseudoInstr(MachineFunction &MF, MachineBasicBlock &MBB,
+                              MachineBasicBlock::iterator I) const {
+  const TargetFrameLowering *TFI = MF.getTarget().getFrameLowering();
+
+  if (!TFI->hasReservedCallFrame(MF)) {
+    MachineInstr *Old = I;
+    uint64_t Amount = Old->getOperand(0).getImm();
+    if (Amount != 0) {
+      // We need to keep the stack aligned properly.  To do this, we round the
+      // amount of space needed for the outgoing arguments up to the next
+      // alignment boundary.
+      Amount = (Amount+StackAlign-1)/StackAlign*StackAlign;
+
+      MachineInstr *New = 0;
+      if (Old->getOpcode() == TII.getCallFrameSetupOpcode()) {
+          for (int i = 0; i<Amount; ++i) {
+            New = BuildMI(MF, Old->getDebugLoc(),
+                        TII.get(AVR::PUSH), AVR::R0);
+            MBB.insert(I, New);
+          }
+      } else {
+        assert(Old->getOpcode() == TII.getCallFrameDestroyOpcode());
+        // factor out the amount the callee already popped.
+        uint64_t CalleeAmt = Old->getOperand(1).getImm();
+        Amount -= CalleeAmt;
+        if (Amount)
+          for (int i = 0; i<Amount; ++i) {
+            New = BuildMI(MF, Old->getDebugLoc(),
+                        TII.get(AVR::POP), AVR::R0);
+            MBB.insert(I, New);
+          }
+      }
+
+      if (New) {
+        // The SRW implicit def is dead.
+        //New->getOperand(3).setIsDead();
+      }
+    }
+  } else if (I->getOpcode() == TII.getCallFrameDestroyOpcode()) {
+    // If we are performing frame pointer elimination and if the callee pops
+    // something off the stack pointer, add it back.
+    if (uint64_t CalleeAmt = I->getOperand(1).getImm()) {
+      MachineInstr *Old = I;
+      MachineInstr *New = 0;
+      for (int i = 0; i<CalleeAmt; ++i) {
+        New = BuildMI(MF, Old->getDebugLoc(),
+		      TII.get(AVR::PUSH), AVR::R0);
+	      MBB.insert(I, New);
+      }
+      // The SRW implicit def is dead.
+      //New->getOperand(3).setIsDead();
+    }
+  }
+
+  MBB.erase(I);
+}
+
+void
+AVRRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II, int unused,
+                                        unsigned int SPAdj, RegScavenger *RS) const {
+  assert(SPAdj == 0 && "Unexpected");
+
+  unsigned i = 0;
+  MachineInstr &MI = *II;
+  MachineBasicBlock &MBB = *MI.getParent();
+  MachineFunction &MF = *MBB.getParent();
+  const TargetFrameLowering *TFI = MF.getTarget().getFrameLowering();
+  DebugLoc dl = MI.getDebugLoc();
+  while (!MI.getOperand(i).isFI()) {
+    ++i;
+    assert(i < MI.getNumOperands() && "Instr doesn't have FrameIndex operand!");
+  }
+
+  int FrameIndex = MI.getOperand(i).getIndex();
+
+  unsigned BasePtr = AVR::Y;
+  int Offset = MF.getFrameInfo()->getObjectOffset(FrameIndex);
+
+  // Fold imm into offset
+  Offset += MI.getOperand(i+1).getImm();
+
+  // The offset from getObjectOffset is negative (stack grows down), 
+  // calculated relative to the SP at the entry of the function 
+  // (and includes FP).
+  // Add 2 bytes to skip past the saved Y, if any (even if not using FP, a constant 2 is given
+  // in TargetFrameLowering's constructor as the LocalAreaOffset). Add stack size to make it
+  // relative to top of the allocated space. Add 1, as the top address is unallocated and allocated space
+  // starts 1 below.
+  // Stack frame layout is
+  // Y -->
+  //            Local variables
+  //            ...
+  // SP@Start->Saved Y
+  //            Return Address
+
+    Offset += 2; 
+    Offset += MF.getFrameInfo()->getStackSize() + 1;
+
+  if (MI.getOpcode() == AVR::MOV8mr) 
+      MI.setDesc(TII.get(AVR::MOV8mr_INDEX));
+  else if (MI.getOpcode() == AVR::MOV8rm) 
+      MI.setDesc(TII.get(AVR::MOV8rm_INDEX));
+
+  MI.getOperand(i).ChangeToRegister(BasePtr, false);
+  MI.getOperand(i+1).ChangeToImmediate(Offset);
+}
+
+void
+AVRRegisterInfo::processFunctionBeforeFrameFinalized(MachineFunction &MF)
+                                                                         const {
+  const TargetFrameLowering *TFI = MF.getTarget().getFrameLowering();
+
+  // Create a frame entry for the FPW register that must be saved.
+  if (TFI->hasFP(MF)) {
+    int FrameIdx = MF.getFrameInfo()->CreateFixedObject(2, -4, true);
+    (void)FrameIdx;
+    assert(FrameIdx == MF.getFrameInfo()->getObjectIndexBegin() &&
+           "Slot for FPW register must be last in order to be found!");
+  }
+}
+
+unsigned AVRRegisterInfo::getFrameRegister(const MachineFunction &MF) const {
+  return AVR::Y;
+}
Index: lib/Target/AVR/AVRRegisterInfo.h
===================================================================
--- lib/Target/AVR/AVRRegisterInfo.h	(revision 0)
+++ lib/Target/AVR/AVRRegisterInfo.h	(revision 0)
@@ -0,0 +1,59 @@
+//===- AVRRegisterInfo.h - AVR Register Information Impl --*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the AVR implementation of the MRegisterInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TARGET_AVRREGISTERINFO_H
+#define LLVM_TARGET_AVRREGISTERINFO_H
+
+#include "llvm/Target/TargetRegisterInfo.h"
+
+#define GET_REGINFO_HEADER
+#include "AVRGenRegisterInfo.inc"
+
+namespace llvm {
+
+class TargetInstrInfo;
+class AVRTargetMachine;
+
+struct AVRRegisterInfo : public AVRGenRegisterInfo {
+private:
+  AVRTargetMachine &TM;
+  const TargetInstrInfo &TII;
+
+  /// StackAlign - Default stack alignment.
+  ///
+  unsigned StackAlign;
+public:
+  AVRRegisterInfo(AVRTargetMachine &tm, const TargetInstrInfo &tii);
+  
+  /// Code Generation virtual methods...
+  const MCPhysReg*getCalleeSavedRegs(const MachineFunction *MF = 0) const;
+
+  BitVector getReservedRegs(const MachineFunction &MF) const;
+  const TargetRegisterClass* getPointerRegClass(unsigned Kind = 0) const;
+
+  void eliminateCallFramePseudoInstr(MachineFunction &MF,
+                                     MachineBasicBlock &MBB,
+                                     MachineBasicBlock::iterator I) const;
+
+  void eliminateFrameIndex(MachineBasicBlock::iterator II, int,
+                           unsigned int SPAdj, RegScavenger *RS = NULL) const;
+
+  void processFunctionBeforeFrameFinalized(MachineFunction &MF) const;
+
+  // Debug information queries.
+  unsigned getFrameRegister(const MachineFunction &MF) const;
+};
+
+} // end namespace llvm
+
+#endif // LLVM_TARGET_AVRREGISTERINFO_H
Index: lib/Target/AVR/AVRSubtarget.cpp
===================================================================
--- lib/Target/AVR/AVRSubtarget.cpp	(revision 0)
+++ lib/Target/AVR/AVRSubtarget.cpp	(revision 0)
@@ -0,0 +1,34 @@
+//===- AVRSubtarget.cpp - AVR Subtarget Information ---------*- C++ -*-=//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the AVR specific subclass of TargetSubtargetInfo.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVRSubtarget.h"
+#include "AVR.h"
+#include "llvm/Support/TargetRegistry.h"
+
+#define GET_SUBTARGETINFO_TARGET_DESC
+#define GET_SUBTARGETINFO_CTOR
+#include "AVRGenSubtargetInfo.inc"
+
+using namespace llvm;
+
+void AVRSubtarget::anchor() { }
+
+AVRSubtarget::AVRSubtarget(const std::string &TT,
+                                 const std::string &CPU,
+                                 const std::string &FS) :
+  AVRGenSubtargetInfo(TT, CPU, FS) {
+  std::string CPUName = "generic";
+
+  // Parse features string.
+  ParseSubtargetFeatures(CPUName, FS);
+}
Index: lib/Target/AVR/AVRSubtarget.h
===================================================================
--- lib/Target/AVR/AVRSubtarget.h	(revision 0)
+++ lib/Target/AVR/AVRSubtarget.h	(revision 0)
@@ -0,0 +1,43 @@
+//====-- AVRSubtarget.h - Define Subtarget for the AVR ---*- C++ -*--===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the AVR specific subclass of TargetSubtargetInfo.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TARGET_AVR_SUBTARGET_H
+#define LLVM_TARGET_AVR_SUBTARGET_H
+
+#include "llvm/Target/TargetSubtargetInfo.h"
+
+#define GET_SUBTARGETINFO_HEADER
+#include "AVRGenSubtargetInfo.inc"
+
+#include <string>
+
+namespace llvm {
+class StringRef;
+
+class AVRSubtarget : public AVRGenSubtargetInfo {
+  virtual void anchor();
+  bool ExtendedInsts;
+public:
+  /// This constructor initializes the data members to match that
+  /// of the specified triple.
+  ///
+  AVRSubtarget(const std::string &TT, const std::string &CPU,
+                  const std::string &FS);
+
+  /// ParseSubtargetFeatures - Parses features string setting specified
+  /// subtarget options.  Definition of function is auto generated by tblgen.
+  void ParseSubtargetFeatures(StringRef CPU, StringRef FS);
+};
+} // End llvm namespace
+
+#endif  // LLVM_TARGET_AVR_SUBTARGET_H
Index: lib/Target/AVR/AVRTargetMachine.cpp
===================================================================
--- lib/Target/AVR/AVRTargetMachine.cpp	(revision 0)
+++ lib/Target/AVR/AVRTargetMachine.cpp	(revision 0)
@@ -0,0 +1,44 @@
+//===-- AVRTargetMachine.cpp - Define TargetMachine for MSP430 ---------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Top-level implementation for the AVR target.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVR.h"
+#include "AVRTargetMachine.h"
+#include "llvm/PassManager.h"
+#include "llvm/CodeGen/Passes.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/Support/TargetRegistry.h"
+using namespace llvm;
+
+extern "C" void LLVMInitializeAVRTarget() {
+  // Register the target.
+  RegisterTargetMachine<AVRTargetMachine> X(TheAVRTarget);
+}
+
+AVRTargetMachine::AVRTargetMachine(const Target &T,
+                                         StringRef TT,
+                                         StringRef CPU,
+                                         StringRef FS,
+                                         const TargetOptions &Options,
+                                         Reloc::Model RM, CodeModel::Model CM,
+                                         CodeGenOpt::Level OL)
+  : LLVMTargetMachine(T, TT, CPU, FS, Options, RM, CM, OL),
+    Subtarget(TT, CPU, FS),
+    DL("e-p:16:8:8-i8:8:8-i16:8:8-i32:8:8-i64:8:8-f32:8:8-f64:8:8-n8:16:32:64"),
+    InstrInfo(*this), TLInfo(*this)
+{
+}
+
+bool AVRTargetMachine::addInstSelector(PassManagerBase &PM){
+    PM.add(createAVRISelDag(*this, getOptLevel()));
+    return false;
+}
Index: lib/Target/AVR/AVRTargetMachine.h
===================================================================
--- lib/Target/AVR/AVRTargetMachine.h	(revision 0)
+++ lib/Target/AVR/AVRTargetMachine.h	(revision 0)
@@ -0,0 +1,68 @@
+//==-- AVRTargetMachine.h - Define TargetMachine for AVR ---*- C++ -*-==//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the AVR specific subclass of TargetMachine.
+//
+//===----------------------------------------------------------------------===//
+
+
+#ifndef LLVM_TARGET_AVR__TARGETMACHINE_H
+#define LLVM_TARGET_AVR_TARGETMACHINE_H
+
+#include "AVRInstrInfo.h"
+#include "AVRISelLowering.h"
+#include "AVRFrameLowering.h"
+//#include "AVRSelectionDAGInfo.h"
+#include "AVRRegisterInfo.h"
+#include "AVRSubtarget.h"
+#include "llvm/Target/TargetFrameLowering.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/IR/DataLayout.h"
+
+namespace llvm {
+
+class AVRTargetMachine : public LLVMTargetMachine {
+  AVRSubtarget		 Subtarget;
+  AVRInstrInfo		 InstrInfo;
+  AVRTargetLowering	 TLInfo;
+  DataLayout DL;
+  //AVRSelectionDAGInfo	 TSInfo;
+  AVRFrameLowering	 FrameLowering;
+
+public:
+  AVRTargetMachine(const Target &T, StringRef TT,
+                      StringRef CPU, StringRef FS, const TargetOptions &Options,
+                      Reloc::Model RM, CodeModel::Model CM,
+                      CodeGenOpt::Level OL);
+
+  virtual const TargetFrameLowering *getFrameLowering() const {
+    return &FrameLowering;
+  }
+
+  virtual const AVRInstrInfo* getInstrInfo() const  { return &InstrInfo; }
+  virtual const AVRSubtarget *getSubtargetImpl() const { return &Subtarget; }
+  virtual const TargetRegisterInfo *getRegisterInfo() const {
+    return &InstrInfo.getRegisterInfo();
+  }
+  virtual const AVRTargetLowering* getTargetLowering() const {
+    return &TLInfo;
+  }
+
+  /*
+  virtual const AVRSelectionDAGInfo* getSelectionDAGInfo() const {
+    return &TSInfo;
+  }
+  */
+
+
+  virtual bool addInstSelector(PassManagerBase &PM);
+}; 
+} // end namespace llvm
+
+#endif // LLVM_TARGET_MSP431_TARGETMACHINE_H
Index: lib/Target/AVR/clang_patch.diff
===================================================================
--- lib/Target/AVR/clang_patch.diff	(revision 0)
+++ lib/Target/AVR/clang_patch.diff	(revision 0)
@@ -0,0 +1,493 @@
+diff --git a/lib/Basic/Targets.cpp b/lib/Basic/Targets.cpp
+index 34258c1..87bb1ee 100644
+--- a/lib/Basic/Targets.cpp
++++ b/lib/Basic/Targets.cpp
+@@ -3219,6 +3219,81 @@ namespace {
+ }
+ 
+ namespace {
++  class AVRTargetInfo : public TargetInfo {
++    static const char * const GCCRegNames[];
++    std::string CPU;
++  public:
++    AVRTargetInfo(const std::string& triple) : TargetInfo(triple) {
++      BigEndian = false;
++      TLSSupported = false;
++      IntWidth = 16; IntAlign = 16;
++      LongWidth = 32; LongLongWidth = 64;
++      LongAlign = LongLongAlign = 16;
++      PointerWidth = 16; PointerAlign = 16;
++      SuitableAlign = 16;
++      SizeType = UnsignedInt;
++      IntMaxType = SignedLong;
++      UIntMaxType = UnsignedLong;
++      IntPtrType = SignedShort;
++      PtrDiffType = SignedInt;
++      SigAtomicType = SignedLong;
++      DescriptionString = "e-p:16:16:16-i8:8:8-i16:16:16-i32:16:32-n8:16";
++   }
++    virtual void getTargetDefines(const LangOptions &Opts,
++                                  MacroBuilder &Builder) const {
++      Builder.defineMacro("AVR");
++      Builder.defineMacro("__AVR__");
++      // FIXME: defines for different 'flavours' of MCU
++    }
++    virtual void getTargetBuiltins(const Builtin::Info *&Records,
++                                   unsigned &NumRecords) const {
++     // FIXME: Implement.
++      Records = 0;
++      NumRecords = 0;
++    }
++    virtual void getGCCRegNames(const char * const *&Names,
++                                unsigned &NumNames) const;
++    virtual void getGCCRegAliases(const GCCRegAlias *&Aliases,
++                                  unsigned &NumAliases) const {
++      // No aliases.
++      Aliases = 0;
++      NumAliases = 0;
++    }
++    virtual bool validateAsmConstraint(const char *&Name,
++                                       TargetInfo::ConstraintInfo &info) const {
++      // No target constraints for now.
++      return false;
++    }
++    virtual const char *getClobbers() const {
++      // FIXME: Is this really right?
++      return "";
++    }
++    virtual const char *getVAListDeclaration() const {
++      // FIXME: implement
++      return "typedef char* __builtin_va_list;";
++   }
++   
++    virtual bool setCPU(const std::string &Name)
++    {
++      CPU = Name;
++      return true;
++    }
++  };
++
++  const char * const AVRTargetInfo::GCCRegNames[] = {
++    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
++    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
++    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
++    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31", "r32"
++  };
++
++  void AVRTargetInfo::getGCCRegNames(const char * const *&Names,
++                                        unsigned &NumNames) const {
++    Names = GCCRegNames;
++    NumNames = llvm::array_lengthof(GCCRegNames);
++  }
++}
++namespace {
+ 
+   // LLVM and Clang cannot be used directly to output native binaries for
+   // target, but is used to compile C code to llvm bitcode with correct
+@@ -3714,6 +3789,9 @@ static TargetInfo *AllocateTarget(const std::string &T) {
+   case llvm::Triple::msp430:
+     return new MSP430TargetInfo(T);
+ 
++  case llvm::Triple::avr:
++     return new AVRTargetInfo(T);
++
+   case llvm::Triple::mips:
+     switch (os) {
+     case llvm::Triple::Linux:
+diff --git a/lib/CodeGen/TargetInfo.cpp b/lib/CodeGen/TargetInfo.cpp
+index 30dcaad..2f0b559 100644
+--- a/lib/CodeGen/TargetInfo.cpp
++++ b/lib/CodeGen/TargetInfo.cpp
+@@ -3031,6 +3031,17 @@ void MSP430TargetCodeGenInfo::SetTargetAttributes(const Decl *D,
+   }
+ }
+ 
++namespace {
++
++class AVRTargetCodeGenInfo : public TargetCodeGenInfo {
++public:
++  AVRTargetCodeGenInfo(CodeGenTypes &CGT)
++    : TargetCodeGenInfo(new DefaultABIInfo(CGT)) {}
++  void SetTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
++                           CodeGen::CodeGenModule &M) const {}
++};
++
++}
+ //===----------------------------------------------------------------------===//
+ // MIPS ABI Implementation.  This works for both little-endian and
+ // big-endian variants.
+@@ -3506,6 +3517,9 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
+   case llvm::Triple::msp430:
+     return *(TheTargetCodeGenInfo = new MSP430TargetCodeGenInfo(Types));
+ 
++  case llvm::Triple::avr:
++    return *(TheTargetCodeGenInfo = new AVRTargetCodeGenInfo(Types));
++
+   case llvm::Triple::tce:
+     return *(TheTargetCodeGenInfo = new TCETargetCodeGenInfo(Types));
+ 
+diff --git a/lib/Driver/HostInfo.cpp b/lib/Driver/HostInfo.cpp
+index 0e78792..08a2f7a 100644
+--- a/lib/Driver/HostInfo.cpp
++++ b/lib/Driver/HostInfo.cpp
+@@ -580,6 +580,11 @@ ToolChain *LinuxHostInfo::CreateToolChain(const ArgList &Args,
+     TC = new toolchains::Hexagon_TC (*this, TCTriple);
+   }
+ 
++  if (!TC && !Arch.compare ("avr")) {
++    llvm::Triple TCTriple (getTriple());
++    TC = new toolchains::AVR_TC (*this, TCTriple);
++  }
++
+   if (!TC) {
+     llvm::Triple TCTriple(getTriple());
+     TCTriple.setArchName(ArchName);
+diff --git a/lib/Driver/ToolChains.cpp b/lib/Driver/ToolChains.cpp
+index b53f2d3..e205f9f 100644
+--- a/lib/Driver/ToolChains.cpp
++++ b/lib/Driver/ToolChains.cpp
+@@ -1435,6 +1435,73 @@ const char *Hexagon_TC::GetForcedPicModel() const {
+ } // End Hexagon
+ 
+ 
++/// AVR Toolchain
++
++AVR_TC::AVR_TC(const HostInfo &Host, const llvm::Triple& Triple)
++  : ToolChain(Host, Triple) {
++  getProgramPaths().push_back(getDriver().getInstalledDir());
++  if (getDriver().getInstalledDir() != getDriver().Dir.c_str())
++    getProgramPaths().push_back(getDriver().Dir);
++}
++
++AVR_TC::~AVR_TC() {
++  // Free tool implementations.
++  for (llvm::DenseMap<unsigned, Tool*>::iterator
++         it = Tools.begin(), ie = Tools.end(); it != ie; ++it)
++    delete it->second;
++}
++
++Tool &AVR_TC::SelectTool(const Compilation &C,
++                             const JobAction &JA,
++                             const ActionList &Inputs) const {
++  Action::ActionClass Key;
++  //   if (JA.getKind () == Action::CompileJobClass)
++  //     Key = JA.getKind ();
++  //     else
++
++  if (getDriver().ShouldUseClangCompiler(C, JA, getTriple()))
++    Key = Action::AnalyzeJobClass;
++  else
++    Key = JA.getKind();
++  //   if ((JA.getKind () == Action::CompileJobClass)
++  //     && (JA.getType () != types::TY_LTO_BC)) {
++  //     Key = JA.getKind ();
++  //   }
++
++  Tool *&T = Tools[Key];
++  if (!T) {
++    switch (Key) {
++    case Action::InputClass:
++    case Action::BindArchClass:
++      assert(0 && "Invalid tool kind.");
++    case Action::AnalyzeJobClass:
++      T = new tools::Clang(*this); break;
++    case Action::AssembleJobClass:
++      T = new tools::avr::Assemble(*this); break;
++    case Action::LinkJobClass:
++      T = new tools::avr::Link(*this); break;
++    default:
++      assert(false && "Unsupported action for AVR target.");
++    }
++  }
++
++  return *T;
++}
++
++bool AVR_TC::IsUnwindTablesDefault() const {
++  // FIXME: Gross; we should probably have some separate target
++  // definition, possibly even reusing the one in clang.
++  return getArchName() == "x86_64";
++}
++
++const char *AVR_TC::GetDefaultRelocationModel() const {
++  return "static";
++}
++
++const char *AVR_TC::GetForcedPicModel() const {
++  return 0;
++} // End AVR
++
+ /// TCEToolChain - A tool chain using the llvm bitcode tools to perform
+ /// all subcommands. See http://tce.cs.tut.fi for our peculiar target.
+ /// Currently does not support anything else but compilation.
+diff --git a/lib/Driver/ToolChains.h b/lib/Driver/ToolChains.h
+index c0860c5..da3ea75 100644
+--- a/lib/Driver/ToolChains.h
++++ b/lib/Driver/ToolChains.h
+@@ -152,6 +152,21 @@ public:
+   virtual const char *GetForcedPicModel() const;
+ };
+ 
++class LLVM_LIBRARY_VISIBILITY AVR_TC : public ToolChain {
++protected:
++  mutable llvm::DenseMap<unsigned, Tool*> Tools;
++
++public:
++  AVR_TC(const HostInfo &Host, const llvm::Triple& Triple);
++  ~AVR_TC();
++
++  virtual Tool &SelectTool(const Compilation &C, const JobAction &JA,
++                           const ActionList &Inputs) const;
++
++  virtual bool IsUnwindTablesDefault() const;
++  virtual const char *GetDefaultRelocationModel() const;
++  virtual const char *GetForcedPicModel() const;
++};
+   /// Darwin - The base Darwin tool chain.
+ class LLVM_LIBRARY_VISIBILITY Darwin : public ToolChain {
+ public:
+diff --git a/lib/Driver/Tools.cpp b/lib/Driver/Tools.cpp
+index 883899d..6a3527b 100644
+--- a/lib/Driver/Tools.cpp
++++ b/lib/Driver/Tools.cpp
+@@ -961,6 +961,11 @@ static Arg* getLastHexagonArchArg (const ArgList &Args)
+   return A;
+ }
+ 
++static const char* getAVRTargetCPU(const ArgList &Args)
++{
++   return "atxmega128a1";
++}
++
+ static const char *getHexagonTargetCPU(const ArgList &Args)
+ {
+   Arg *A;
+@@ -2852,6 +2857,182 @@ void hexagon::Link::ConstructJob(Compilation &C, const JobAction &JA,
+     if (II.getType() == types::TY_LLVM_IR || II.getType() == types::TY_LTO_IR ||
+         II.getType() == types::TY_LLVM_BC || II.getType() == types::TY_LTO_BC)
+       D.Diag(clang::diag::err_drv_no_linker_llvm_support)
++        << getToolChain().getTripleString(); else if (II.getType() == types::TY_AST)
++      D.Diag(clang::diag::err_drv_no_ast_support)
++        << getToolChain().getTripleString();
++
++    if (II.isFilename())
++      CmdArgs.push_back(II.getFilename());
++    else
++      // Don't render as input, we need gcc to do the translations. FIXME: Pranav: What is this ?
++      II.getInputArg().render(Args, CmdArgs);
++  }
++  C.addCommand(new Command(JA, *this, Exec, CmdArgs));
++
++}
++// Hexagon tools end.
++// AVR tools start.
++void avr::Assemble::RenderExtraToolArgs(const JobAction &JA,
++                                        ArgStringList &CmdArgs) const {
++
++}
++void avr::Assemble::ConstructJob(Compilation &C, const JobAction &JA,
++                               const InputInfo &Output,
++                               const InputInfoList &Inputs,
++                               const ArgList &Args,
++                               const char *LinkingOutput) const {
++
++  const Driver &D = getToolChain().getDriver();
++  ArgStringList CmdArgs;
++
++  for (ArgList::const_iterator
++         it = Args.begin(), ie = Args.end(); it != ie; ++it) {
++    Arg *A = *it;
++    if (A->getOption().hasForwardToGCC()) {
++      // Don't forward any -g arguments to assembly steps.
++      if (isa<AssembleJobAction>(JA) &&
++          A->getOption().matches(options::OPT_g_Group))
++        continue;
++
++      // It is unfortunate that we have to claim here, as this means
++      // we will basically never report anything interesting for
++      // platforms using a generic gcc, even if we are just using gcc
++      // to get to the assembler.
++      A->claim();
++      A->render(Args, CmdArgs);
++    }
++  }
++
++  //std::string MCUString = "-mmcu=";
++  //MCUString += getAVRTargetCPU(Args);
++  //CmdArgs.push_back(Args.MakeArgString(MCUString));
++
++  RenderExtraToolArgs(JA, CmdArgs);
++
++  if (Output.isFilename()) {
++    CmdArgs.push_back("-o");
++    CmdArgs.push_back(Output.getFilename());
++  } else {
++    assert(Output.isNothing() && "Unexpected output");
++    CmdArgs.push_back("-fsyntax-only");
++  }
++
++
++  // Only pass -x if gcc will understand it; otherwise hope gcc
++  // understands the suffix correctly. The main use case this would go
++  // wrong in is for linker inputs if they happened to have an odd
++  // suffix; really the only way to get this to happen is a command
++  // like '-x foobar a.c' which will treat a.c like a linker input.
++  //
++  // FIXME: For the linker case specifically, can we safely convert
++  // inputs into '-Wl,' options?
++  for (InputInfoList::const_iterator
++         it = Inputs.begin(), ie = Inputs.end(); it != ie; ++it) {
++    const InputInfo &II = *it;
++
++    // Don't try to pass LLVM or AST inputs to a generic gcc.
++    if (II.getType() == types::TY_LLVM_IR || II.getType() == types::TY_LTO_IR ||
++        II.getType() == types::TY_LLVM_BC || II.getType() == types::TY_LTO_BC)
++      D.Diag(clang::diag::err_drv_no_linker_llvm_support)
++        << getToolChain().getTripleString();
++    else if (II.getType() == types::TY_AST)
++      D.Diag(clang::diag::err_drv_no_ast_support)
++        << getToolChain().getTripleString();
++
++    if (II.isFilename())
++      CmdArgs.push_back(II.getFilename());
++    else
++      // Don't render as input, we need gcc to do the translations. FIXME: Pranav: What is this ?
++      II.getInputArg().render(Args, CmdArgs);
++  }
++
++  const char *GCCName = "avr-as";
++  const char *Exec =
++    Args.MakeArgString(getToolChain().GetProgramPath(GCCName));
++  C.addCommand(new Command(JA, *this, Exec, CmdArgs));
++
++}
++void avr::Link::RenderExtraToolArgs(const JobAction &JA,
++                                    ArgStringList &CmdArgs) const {
++  // The types are (hopefully) good enough.
++}
++
++void avr::Link::ConstructJob(Compilation &C, const JobAction &JA,
++                               const InputInfo &Output,
++                               const InputInfoList &Inputs,
++                               const ArgList &Args,
++                               const char *LinkingOutput) const {
++
++  const Driver &D = getToolChain().getDriver();
++  ArgStringList CmdArgs;
++
++  for (ArgList::const_iterator
++         it = Args.begin(), ie = Args.end(); it != ie; ++it) {
++    Arg *A = *it;
++    if (A->getOption().hasForwardToGCC()) {
++      // Don't forward any -g arguments to assembly steps.
++      if (isa<AssembleJobAction>(JA) &&
++          A->getOption().matches(options::OPT_g_Group))
++        continue;
++
++      // It is unfortunate that we have to claim here, as this means
++      // we will basically never report anything interesting for
++      // platforms using a generic gcc, even if we are just using gcc
++      // to get to the assembler.
++      A->claim();
++      A->render(Args, CmdArgs);
++    }
++  }
++
++  RenderExtraToolArgs(JA, CmdArgs);
++
++  // Add Arch Information
++  /*
++  Arg *A;
++  if ((A = getLastHexagonArchArg (Args))) {
++    if ((A->getOption().matches(options::OPT_march_EQ)) ||
++        (A->getOption().matches(options::OPT_mcpu_EQ))) {
++    llvm::StringRef WhichHexagon = A->getValue(Args);
++    if (WhichHexagon == "v2")
++      CmdArgs.push_back("-mv2");
++    else if (WhichHexagon == "v3")
++      CmdArgs.push_back ("-mv3");
++    else if (WhichHexagon == "v4")
++      CmdArgs.push_back ("-mv4");
++    else
++      assert (0 && "Unknown -march or -mcpu value");
++    }
++    else {
++      if (A->getOption().matches(options::OPT_mv2) ||
++          A->getOption().matches(options::OPT_mv3) ||
++          A->getOption().matches(options::OPT_mv4))
++        A->render(Args, CmdArgs);
++      else
++        assert(0 && "Unknown -m argument.");
++    }
++
++  }
++  CmdArgs.push_back("-mqdsp6-compat");
++  */
++
++  const char *GCCName;
++  GCCName = "avr-ld";
++  const char *Exec =
++    Args.MakeArgString(getToolChain().GetProgramPath(GCCName));
++
++  if (Output.isFilename()) {
++    CmdArgs.push_back("-o");
++    CmdArgs.push_back(Output.getFilename());
++  }
++
++  for (InputInfoList::const_iterator
++         it = Inputs.begin(), ie = Inputs.end(); it != ie; ++it) {
++    const InputInfo &II = *it;
++
++    // Don't try to pass LLVM or AST inputs to a generic gcc.
++    if (II.getType() == types::TY_LLVM_IR || II.getType() == types::TY_LTO_IR ||
++        II.getType() == types::TY_LLVM_BC || II.getType() == types::TY_LTO_BC)
++      D.Diag(clang::diag::err_drv_no_linker_llvm_support)
+         << getToolChain().getTripleString();
+     else if (II.getType() == types::TY_AST)
+       D.Diag(clang::diag::err_drv_no_ast_support)
+diff --git a/lib/Driver/Tools.h b/lib/Driver/Tools.h
+index b304e96..da7c548 100644
+--- a/lib/Driver/Tools.h
++++ b/lib/Driver/Tools.h
+@@ -189,6 +189,41 @@ namespace hexagon {
+   };
+ } // end namespace hexagon.
+ 
++// avr assembler and linker
++
++namespace avr {
++  class LLVM_LIBRARY_VISIBILITY Assemble : public Tool {
++  public:
++    Assemble(const ToolChain &TC) : Tool("avr::Assemble",
++      "avr-as", TC) {}
++
++    virtual bool hasIntegratedCPP() const { return false; }
++
++    virtual void RenderExtraToolArgs(const JobAction &JA,
++                                     ArgStringList &CmdArgs) const;
++    virtual void ConstructJob(Compilation &C, const JobAction &JA,
++                              const InputInfo &Output,
++                              const InputInfoList &Inputs,
++                              const ArgList &TCArgs,
++                              const char *LinkingOutput) const;
++  };
++
++  class LLVM_LIBRARY_VISIBILITY Link : public Tool {
++  public:
++    Link(const ToolChain &TC) : Tool("avr::Link",
++      "avr-ld", TC) {}
++
++    virtual bool hasIntegratedCPP() const { return false; }
++
++    virtual void RenderExtraToolArgs(const JobAction &JA,
++                                     ArgStringList &CmdArgs) const;
++    virtual void ConstructJob(Compilation &C, const JobAction &JA,
++                              const InputInfo &Output,
++                              const InputInfoList &Inputs,
++                              const ArgList &TCArgs,
++                              const char *LinkingOutput) const;
++  };
++} // end namespace avr.
+ 
+ namespace darwin {
+   class LLVM_LIBRARY_VISIBILITY DarwinTool : public Tool {
Index: lib/Target/AVR/CMakeLists.txt
===================================================================
--- lib/Target/AVR/CMakeLists.txt	(revision 0)
+++ lib/Target/AVR/CMakeLists.txt	(revision 0)
@@ -0,0 +1,30 @@
+set(LLVM_TARGET_DEFINITIONS AVR.td)
+
+tablegen(LLVM AVRGenAsmMatcher.inc -gen-asm-matcher)
+tablegen(LLVM AVRGenAsmWriter.inc -gen-asm-writer)
+tablegen(LLVM AVRGenCallingConv.inc -gen-callingconv)
+tablegen(LLVM AVRGenDisassemblerTables.inc -gen-disassembler)
+tablegen(LLVM AVRGenInstrInfo.inc -gen-instr-info)
+tablegen(LLVM AVRGenMCCodeEmitter.inc -gen-emitter -mc-emitter)
+tablegen(LLVM AVRGenMCPseudoLowering.inc -gen-pseudo-lowering)
+tablegen(LLVM AVRGenRegisterInfo.inc -gen-register-info)
+tablegen(LLVM AVRGenDAGISel.inc -gen-dag-isel)
+tablegen(LLVM AVRGenSubtargetInfo.inc -gen-subtarget)
+add_public_tablegen_target(AVRCommonTableGen)
+
+add_llvm_target(AVRCodeGen
+    AVRAsmPrinter.cpp
+    AVRFrameLowering.cpp
+    AVRInstrInfo.cpp
+    AVRISelDAGToDAG.cpp
+    AVRISelLowering.cpp
+    AVRMachineFunctionInfo.cpp
+    AVRMCInstLower.cpp
+    AVRRegisterInfo.cpp
+    AVRSubtarget.cpp
+    AVRTargetMachine.cpp
+  )
+
+add_subdirectory(InstPrinter)
+add_subdirectory(MCTargetDesc)
+add_subdirectory(TargetInfo)
Index: lib/Target/AVR/InstPrinter/AVRInstPrinter.cpp
===================================================================
--- lib/Target/AVR/InstPrinter/AVRInstPrinter.cpp	(revision 0)
+++ lib/Target/AVR/InstPrinter/AVRInstPrinter.cpp	(revision 0)
@@ -0,0 +1,116 @@
+//===-- AVRInstPrinter.cpp - Convert AVR MCInst to assembly syntax --===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This class prints an AVR MCInst to a .s file.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "asm-printer"
+#include "AVR.h"
+#include "AVRInstPrinter.h"
+#include "llvm/MC/MCInst.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCExpr.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/FormattedStream.h"
+using namespace llvm;
+
+
+// Include the auto-generated portion of the assembly writer.
+#include "AVRGenAsmWriter.inc"
+
+void AVRInstPrinter::printInst(const MCInst *MI, raw_ostream &O,
+                                  StringRef Annot) {
+  printInstruction(MI, O);
+  printAnnotation(O, Annot);
+}
+
+void AVRInstPrinter::printPCRelImmOperand(const MCInst *MI, unsigned OpNo,
+                                             raw_ostream &O) {
+  const MCOperand &Op = MI->getOperand(OpNo);
+  if (Op.isImm())
+    O << Op.getImm();
+  else {
+    assert(Op.isExpr() && "unknown pcrel immediate operand");
+    O << *Op.getExpr();
+  }
+}
+
+void AVRInstPrinter::printOperand(const MCInst *MI, unsigned OpNo,
+                                     raw_ostream &O, const char *Modifier) {
+  assert((Modifier == 0 || Modifier[0] == 0) && "No modifiers supported");
+  const MCOperand &Op = MI->getOperand(OpNo);
+  if (Op.isReg()) {
+    O << getRegisterName(Op.getReg());
+  } else if (Op.isImm()) {
+    O << Op.getImm();
+  } else {
+    assert(Op.isExpr() && "unknown operand kind in printOperand");
+    O << *Op.getExpr();
+  }
+}
+
+void AVRInstPrinter::printSrcMemOperand(const MCInst *MI, unsigned OpNo,
+                                           raw_ostream &O,
+                                           const char *Modifier) {
+  const MCOperand &Base = MI->getOperand(OpNo);
+  const MCOperand &Disp = MI->getOperand(OpNo+1);
+
+  // Print displacement first
+
+  // If the global address expression is a part of displacement field with a
+  // register base, we should not emit any prefix symbol here, e.g.
+  //   mov.w &foo, r1
+  // vs
+  //   mov.w glb(r1), r2
+  // Otherwise (!) AVR-as will silently miscompile the output :(
+  //if (!Base.getReg())
+  //  O << '&';
+
+  // Print register base field
+  if (Base.getReg())
+    O << getRegisterName(Base.getReg()) << '+';
+
+  if (Disp.isExpr())
+    O << *Disp.getExpr();
+  else {
+    assert(Disp.isImm() && "Expected immediate in displacement field");
+    O << Disp.getImm();
+  }
+
+}
+
+void AVRInstPrinter::printCCOperand(const MCInst *MI, unsigned OpNo,
+                                       raw_ostream &O) {
+  unsigned CC = MI->getOperand(OpNo).getImm();
+
+  switch (CC) {
+  default:
+   llvm_unreachable("Unsupported CC code");
+   break;
+  case AVRCC::COND_E:
+   O << "eq";
+   break;
+  case AVRCC::COND_NE:
+   O << "ne";
+   break;
+  case AVRCC::COND_HS:
+   O << "hs";
+   break;
+  case AVRCC::COND_LO:
+   O << "lo";
+   break;
+  case AVRCC::COND_GE:
+   O << "ge";
+   break;
+  case AVRCC::COND_L:
+   O << 'l';
+   break;
+  }
+}
Index: lib/Target/AVR/InstPrinter/AVRInstPrinter.h
===================================================================
--- lib/Target/AVR/InstPrinter/AVRInstPrinter.h	(revision 0)
+++ lib/Target/AVR/InstPrinter/AVRInstPrinter.h	(revision 0)
@@ -0,0 +1,44 @@
+//===-- AVRInstPrinter.h - Convert AVR MCInst to assembly syntax ----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This class prints a AVR MCInst to a .s file.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef AVRINSTPRINTER_H
+#define AVRINSTPRINTER_H
+
+#include "llvm/MC/MCInstPrinter.h"
+
+namespace llvm {
+  class MCOperand;
+
+  class AVRInstPrinter : public MCInstPrinter {
+  public:
+    AVRInstPrinter(const MCAsmInfo &MAI, const MCInstrInfo &MII,
+                      const MCRegisterInfo &MRI)
+      : MCInstPrinter(MAI, MII, MRI) {}
+
+    virtual void printInst(const MCInst *MI, raw_ostream &O, StringRef Annot);
+
+    // Autogenerated by tblgen.
+    void printInstruction(const MCInst *MI, raw_ostream &O);
+    static const char *getRegisterName(unsigned RegNo);
+
+    void printOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O,
+                      const char *Modifier = 0);
+    void printPCRelImmOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O);
+    void printSrcMemOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O,
+                            const char *Modifier = 0);
+    void printCCOperand(const MCInst *MI, unsigned OpNo, raw_ostream &O);
+
+  };
+}
+
+#endif
Index: lib/Target/AVR/InstPrinter/CMakeLists.txt
===================================================================
--- lib/Target/AVR/InstPrinter/CMakeLists.txt	(revision 0)
+++ lib/Target/AVR/InstPrinter/CMakeLists.txt	(revision 0)
@@ -0,0 +1,7 @@
+include_directories( ${CMAKE_CURRENT_BINARY_DIR}/.. ${CMAKE_CURRENT_SOURCE_DIR}/.. )
+
+add_llvm_library(LLVMAVRAsmPrinter
+    AVRInstPrinter.cpp
+  )
+
+add_dependencies(LLVMAVRAsmPrinter AVRCommonTableGen)
Index: lib/Target/AVR/InstPrinter/LLVMBuild.txt
===================================================================
--- lib/Target/AVR/InstPrinter/LLVMBuild.txt	(revision 0)
+++ lib/Target/AVR/InstPrinter/LLVMBuild.txt	(revision 0)
@@ -0,0 +1,23 @@
+;===- ./lib/Target/AVR/InstPrinter/LLVMBuild.txt ------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Library
+name = AVRAsmPrinter
+parent = AVR
+required_libraries = MC Support
+add_to_library_groups = AVR
Index: lib/Target/AVR/InstPrinter/Makefile
===================================================================
--- lib/Target/AVR/InstPrinter/Makefile	(revision 0)
+++ lib/Target/AVR/InstPrinter/Makefile	(revision 0)
@@ -0,0 +1,15 @@
+##===- lib/Target/AVR/AsmPrinter/Makefile ---------------*- Makefile -*-===##
+#
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+#
+##===----------------------------------------------------------------------===##
+LEVEL = ../../../..
+LIBRARYNAME = LLVMAVRAsmPrinter
+
+# Hack: we need to include 'main' AVR target directory to grab private headers
+CPP.Flags += -I$(PROJ_OBJ_DIR)/.. -I$(PROJ_SRC_DIR)/..
+
+include $(LEVEL)/Makefile.common
Index: lib/Target/AVR/LLVMBuild.txt
===================================================================
--- lib/Target/AVR/LLVMBuild.txt	(revision 0)
+++ lib/Target/AVR/LLVMBuild.txt	(revision 0)
@@ -0,0 +1,32 @@
+;===- ./lib/Target/AVR/LLVMBuild.txt ------------------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[common]
+subdirectories = InstPrinter MCTargetDesc TargetInfo
+
+[component_0]
+type = TargetGroup
+name = AVR
+parent = Target
+has_asmprinter = 1
+
+[component_1]
+type = Library
+name = AVRCodeGen
+parent = AVR
+required_libraries = AsmPrinter CodeGen Core MC AVRAsmPrinter AVRDesc AVRInfo SelectionDAG Support Target
+add_to_library_groups = AVR
Index: lib/Target/AVR/Makefile
===================================================================
--- lib/Target/AVR/Makefile	(revision 0)
+++ lib/Target/AVR/Makefile	(revision 0)
@@ -0,0 +1,23 @@
+##===- lib/Target/AVR/Makefile --------------------------*- Makefile -*-===##
+# 
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source 
+# License. See LICENSE.TXT for details.
+# 
+##===----------------------------------------------------------------------===##
+
+LEVEL = ../../..
+LIBRARYNAME = LLVMAVRCodeGen
+TARGET = AVR
+
+# Make sure that tblgen is run, first thing.
+BUILT_SOURCES = AVRGenRegisterInfo.inc AVRGenInstrInfo.inc AVRGenAsmWriter.inc AVRGenDAGISel.inc AVRGenCallingConv.inc AVRGenSubtargetInfo.inc\
+		#MSP430GenAsmWriter.inc \
+		MSP430GenDAGISel.inc MSP430GenCallingConv.inc \
+		MSP430GenSubtargetInfo.inc
+
+DIRS = InstPrinter TargetInfo MCTargetDesc 
+
+include $(LEVEL)/Makefile.common
+
Index: lib/Target/AVR/MCTargetDesc/AVRMCAsmInfo.cpp
===================================================================
--- lib/Target/AVR/MCTargetDesc/AVRMCAsmInfo.cpp	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/AVRMCAsmInfo.cpp	(revision 0)
@@ -0,0 +1,30 @@
+//===-- AVRMCAsmInfo.cpp - AVR asm properties -----------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the declarations of the AVRMCAsmInfo properties.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVRMCAsmInfo.h"
+using namespace llvm;
+
+void AVRMCAsmInfo::anchor() { }
+
+AVRMCAsmInfo::AVRMCAsmInfo(const Target &T, StringRef TT) {
+  PointerSize = 2;
+
+  PrivateGlobalPrefix = ".L";
+  WeakRefDirective ="\t.weak\t";
+  PCSymbol=".";
+  CommentString = ";";
+
+  AlignmentIsInBytes = false;
+  AllowNameToStartWithDigit = true;
+  UsesELFSectionDirectiveForBSS = true;
+}
Index: lib/Target/AVR/MCTargetDesc/AVRMCAsmInfo.h
===================================================================
--- lib/Target/AVR/MCTargetDesc/AVRMCAsmInfo.h	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/AVRMCAsmInfo.h	(revision 0)
@@ -0,0 +1,31 @@
+//=====-- AVRMCAsmInfo.h - AVR asm properties -----------*- C++ -*--====//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source 
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the declaration of the AVRMCAsmInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef AVRTARGETASMINFO_H
+#define AVRTARGETASMINFO_H
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/MC/MCAsmInfo.h"
+
+namespace llvm {
+  class Target;
+
+  class AVRMCAsmInfo : public MCAsmInfo {
+    virtual void anchor();
+  public:
+    explicit AVRMCAsmInfo(const Target &T, StringRef TT);
+  };
+
+} // namespace llvm
+
+#endif
Index: lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.cpp
===================================================================
--- lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.cpp	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.cpp	(revision 0)
@@ -0,0 +1,92 @@
+//===-- AVRMCTargetDesc.cpp - AVR Target Descriptions -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file provides AVR specific target descriptions.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVRMCTargetDesc.h"
+#include "AVRMCAsmInfo.h"
+#include "InstPrinter/AVRInstPrinter.h"
+#include "llvm/MC/MCCodeGenInfo.h"
+#include "llvm/MC/MCInstrInfo.h"
+#include "llvm/MC/MCRegisterInfo.h"
+#include "llvm/MC/MCSubtargetInfo.h"
+#include "llvm/Support/TargetRegistry.h"
+
+#define GET_REGINFO_MC_DESC
+#include "AVRGenRegisterInfo.inc"
+using namespace llvm;
+
+#define GET_INSTRINFO_MC_DESC
+#include "AVRGenInstrInfo.inc"
+
+#define GET_SUBTARGETINFO_MC_DESC
+#include "AVRGenSubtargetInfo.inc"
+
+
+
+static MCInstrInfo *createAVRMCInstrInfo() {
+  MCInstrInfo *X = new MCInstrInfo();
+  InitAVRMCInstrInfo(X);
+  return X;
+}
+
+static MCRegisterInfo *createAVRMCRegisterInfo(StringRef TT) {
+  MCRegisterInfo *X = new MCRegisterInfo();
+  InitAVRMCRegisterInfo(X, AVR::PC);
+  return X;
+}
+
+
+static MCSubtargetInfo *createAVRMCSubtargetInfo(StringRef TT, StringRef CPU,
+                                                    StringRef FS) {
+  MCSubtargetInfo *X = new MCSubtargetInfo();
+  InitAVRMCSubtargetInfo(X, TT, CPU, FS);
+  return X;
+}
+
+static MCCodeGenInfo *createAVRCCodeGenInfo(StringRef TT, Reloc::Model RM,
+                                                CodeModel::Model CM,
+                                                CodeGenOpt::Level OL) {
+  MCCodeGenInfo *X = new MCCodeGenInfo();
+  X->InitMCCodeGenInfo(RM, CM, OL);
+  return X;
+}
+
+static MCInstPrinter *createAVRMCInstPrinter(const Target &T,
+                                                unsigned SyntaxVariant,
+                                                const MCAsmInfo &MAI,
+                                                const MCInstrInfo &MII,
+                                                const MCRegisterInfo &MRI,
+                                                const MCSubtargetInfo &STI) {
+    return new AVRInstPrinter(MAI, MII, MRI);
+}
+
+extern "C" void LLVMInitializeAVRTargetMC() {
+  //  Register the MC asm info.
+  RegisterMCAsmInfo<AVRMCAsmInfo> X(TheAVRTarget);
+
+  // Register the MC codegen info.
+  TargetRegistry::RegisterMCCodeGenInfo(TheAVRTarget,
+                                        createAVRCCodeGenInfo);
+
+  // Register the MC instruction info.
+  TargetRegistry::RegisterMCInstrInfo(TheAVRTarget, createAVRMCInstrInfo);
+
+  // Register the MC register info.
+  TargetRegistry::RegisterMCRegInfo(TheAVRTarget,
+                                     createAVRMCRegisterInfo);
+
+  // Register the MC subtarget info.
+  TargetRegistry::RegisterMCSubtargetInfo(TheAVRTarget, createAVRMCSubtargetInfo);
+
+  // Register the MCInstPrinter.
+  TargetRegistry::RegisterMCInstPrinter(TheAVRTarget, createAVRMCInstPrinter);
+}
Index: lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.h
===================================================================
--- lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.h	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/AVRMCTargetDesc.h	(revision 0)
@@ -0,0 +1,38 @@
+//===-- AVRMCTargetDesc.h - AVR Target Descriptions -------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file provides AVR specific target descriptions.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef AVRMCTARGETDESC_H
+#define AVRMCTARGETDESC_H
+
+namespace llvm {
+class MCSubtargetInfo;
+class Target;
+class StringRef;
+
+extern Target TheAVRTarget;
+
+} // End llvm namespace
+
+// Defines symbolic names for AVR registers.
+// This defines a mapping from register name to register number.
+#define GET_REGINFO_ENUM
+#include "AVRGenRegisterInfo.inc"
+
+// Defines symbolic names for the AVR instructions.
+#define GET_INSTRINFO_ENUM
+#include "AVRGenInstrInfo.inc"
+
+#define GET_SUBTARGETINFO_ENUM
+#include "AVRGenSubtargetInfo.inc"
+
+#endif
Index: lib/Target/AVR/MCTargetDesc/CMakeLists.txt
===================================================================
--- lib/Target/AVR/MCTargetDesc/CMakeLists.txt	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/CMakeLists.txt	(revision 0)
@@ -0,0 +1,8 @@
+add_llvm_library(LLVMAVRDesc
+  AVRMCAsmInfo.cpp
+  AVRMCTargetDesc.cpp
+  )
+add_dependencies(LLVMAVRDesc AVRCommonTableGen)
+
+# Hack: we need to include 'main' target directory to grab private headers
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/.. ${CMAKE_CURRENT_BINARY_DIR}/..)
Index: lib/Target/AVR/MCTargetDesc/LLVMBuild.txt
===================================================================
--- lib/Target/AVR/MCTargetDesc/LLVMBuild.txt	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/LLVMBuild.txt	(revision 0)
@@ -0,0 +1,23 @@
+;===- ./lib/Target/AVR/MCTargetDesc/LLVMBuild.txt -----------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Library
+name = AVRDesc
+parent = AVR
+required_libraries = MC AVRAsmPrinter AVRInfo Support Target
+add_to_library_groups = AVR
Index: lib/Target/AVR/MCTargetDesc/Makefile
===================================================================
--- lib/Target/AVR/MCTargetDesc/Makefile	(revision 0)
+++ lib/Target/AVR/MCTargetDesc/Makefile	(revision 0)
@@ -0,0 +1,16 @@
+##===- lib/Target/AVR/TargetDesc/Makefile ---------------*- Makefile -*-===##
+#
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+#
+##===----------------------------------------------------------------------===##
+
+LEVEL = ../../../..
+LIBRARYNAME = LLVMAVRDesc
+
+# Hack: we need to include 'main' target directory to grab private headers
+CPP.Flags += -I$(PROJ_OBJ_DIR)/.. -I$(PROJ_SRC_DIR)/..
+
+include $(LEVEL)/Makefile.common
Index: lib/Target/AVR/patch.diff
===================================================================
--- lib/Target/AVR/patch.diff	(revision 0)
+++ lib/Target/AVR/patch.diff	(revision 0)
@@ -0,0 +1,156 @@
+diff --git a/configure b/configure
+index 7c86dbf..d4bb66b 100755
+--- a/configure
++++ b/configure
+@@ -1419,7 +1419,7 @@ Optional Features:
+   --enable-targets        Build specific host targets: all or
+                           target1,target2,... Valid targets are: host, x86,
+                           x86_64, sparc, powerpc, arm, mips, spu, hexagon,
+-                          xcore, msp430, ptx, cbe, and cpp (default=all)
++                          xcore, msp430, avr, ptx, cbe, and cpp (default=all)
+   --enable-cbe-printf-a   Enable C Backend output with hex floating point via
+                           %a (default is YES)
+   --enable-bindings       Build specific language bindings:
+@@ -3888,6 +3888,7 @@ else
+   mips-*)                 llvm_cv_target_arch="Mips" ;;
+   xcore-*)                llvm_cv_target_arch="XCore" ;;
+   msp430-*)               llvm_cv_target_arch="MSP430" ;;
++  avr-*)		  llvm_cv_target_arch="AVR" ;;
+   hexagon-*)              llvm_cv_target_arch="Hexagon" ;;
+   mblaze-*)               llvm_cv_target_arch="MBlaze" ;;
+   ptx-*)                  llvm_cv_target_arch="PTX" ;;
+@@ -5109,6 +5110,8 @@ else
+  ;;
+     MSP430)      TARGET_HAS_JIT=0
+  ;;
++   AVR)		 TARGET_HAS_JIT=0
++ ;;
+     Hexagon)     TARGET_HAS_JIT=0
+  ;;
+     MBlaze)      TARGET_HAS_JIT=0
+@@ -5299,7 +5302,7 @@ if test "$enableval" = host-only ; then
+   enableval=host
+ fi
+ case "$enableval" in
+-  all) TARGETS_TO_BUILD="X86 Sparc PowerPC ARM Mips CellSPU XCore MSP430 CBackend CppBackend MBlaze PTX Hexagon" ;;
++  all) TARGETS_TO_BUILD="X86 Sparc PowerPC ARM Mips CellSPU XCore MSP430 AVR CBackend CppBackend MBlaze PTX Hexagon" ;;
+   *)for a_target in `echo $enableval|sed -e 's/,/ /g' ` ; do
+       case "$a_target" in
+         x86)      TARGETS_TO_BUILD="X86 $TARGETS_TO_BUILD" ;;
+@@ -5311,6 +5314,7 @@ case "$enableval" in
+         spu)      TARGETS_TO_BUILD="CellSPU $TARGETS_TO_BUILD" ;;
+         xcore)    TARGETS_TO_BUILD="XCore $TARGETS_TO_BUILD" ;;
+         msp430)   TARGETS_TO_BUILD="MSP430 $TARGETS_TO_BUILD" ;;
++	avr)	  TARGETS_TO_BUILD="AVR $TARGETS_TO_BUILD" ;;
+         cbe)      TARGETS_TO_BUILD="CBackend $TARGETS_TO_BUILD" ;;
+         cpp)      TARGETS_TO_BUILD="CppBackend $TARGETS_TO_BUILD" ;;
+         hexagon)  TARGETS_TO_BUILD="Hexagon $TARGETS_TO_BUILD" ;;
+@@ -5327,6 +5331,7 @@ case "$enableval" in
+             CellSPU|SPU) TARGETS_TO_BUILD="CellSPU $TARGETS_TO_BUILD" ;;
+             XCore)       TARGETS_TO_BUILD="XCore $TARGETS_TO_BUILD" ;;
+             MSP430)      TARGETS_TO_BUILD="MSP430 $TARGETS_TO_BUILD" ;;
++	    AVR)	 TARGETS_TO_BUILD="AVR $TARGETS_TO_BUILD" ;;
+             Hexagon)     TARGETS_TO_BUILD="Hexagon $TARGETS_TO_BUILD" ;;
+             PTX)         TARGETS_TO_BUILD="PTX $TARGETS_TO_BUILD" ;;
+             *)       { { echo "$as_me:$LINENO: error: Can not set target to build" >&5
+diff --git a/include/llvm/ADT/Triple.h b/include/llvm/ADT/Triple.h
+index 4739fb5..ed0e11c 100644
+--- a/include/llvm/ADT/Triple.h
++++ b/include/llvm/ADT/Triple.h
+@@ -51,6 +51,7 @@ public:
+     mips64,  // MIPS64: mips64
+     mips64el,// MIPS64EL: mips64el
+     msp430,  // MSP430: msp430
++    avr,     // AVR : avr
+     ppc,     // PPC: powerpc
+     ppc64,   // PPC64: powerpc64, ppu
+     sparc,   // Sparc: sparc
+diff --git a/lib/Support/Triple.cpp b/lib/Support/Triple.cpp
+index 8f58e70..f965cf2 100644
+--- a/lib/Support/Triple.cpp
++++ b/lib/Support/Triple.cpp
+@@ -26,6 +26,7 @@ const char *Triple::getArchTypeName(ArchType Kind) {
+   case mips64:  return "mips64";
+   case mips64el:return "mips64el";
+   case msp430:  return "msp430";
++  case avr:	return "avr";
+   case ppc64:   return "powerpc64";
+   case ppc:     return "powerpc";
+   case sparc:   return "sparc";
+@@ -145,6 +146,8 @@ Triple::ArchType Triple::getArchTypeForLLVMName(StringRef Name) {
+     return mips64el;
+   if (Name == "msp430")
+     return msp430;
++  if (Name == "avr")
++    return avr;
+   if (Name == "ppc64")
+     return ppc64;
+   if (Name == "ppc32")
+@@ -290,6 +293,8 @@ Triple::ArchType Triple::ParseArch(StringRef ArchName) {
+     return cellspu;
+   else if (ArchName == "msp430")
+     return msp430;
++  else if (ArchName == "avr")
++    return avr;
+   else if (ArchName == "mips" || ArchName == "mipseb" ||
+            ArchName == "mipsallegrex")
+     return mips;
+diff --git a/projects/sample/configure b/projects/sample/configure
+index 860faa2..38f6bf0 100755
+--- a/projects/sample/configure
++++ b/projects/sample/configure
+@@ -3843,6 +3843,7 @@ else
+   mips-*)                 llvm_cv_target_arch="Mips" ;;
+   xcore-*)                llvm_cv_target_arch="XCore" ;;
+   msp430-*)               llvm_cv_target_arch="MSP430" ;;
++  avr-*)		  llvm_cv_target_arch="AVR" ;;
+   hexagon-*)              llvm_cv_target_arch="Hexagon" ;;
+   mblaze-*)               llvm_cv_target_arch="MBlaze" ;;
+   ptx-*)                  llvm_cv_target_arch="PTX" ;;
+@@ -5045,6 +5046,8 @@ else
+  ;;
+     MSP430)      TARGET_HAS_JIT=0
+  ;;
++    AVR)         TARGET_HAS_JIT=0
++;;
+     Hexagon)     TARGET_HAS_JIT=0
+  ;;
+     MBlaze)      TARGET_HAS_JIT=0
+@@ -5235,7 +5238,7 @@ if test "$enableval" = host-only ; then
+   enableval=host
+ fi
+ case "$enableval" in
+-  all) TARGETS_TO_BUILD="X86 Sparc PowerPC ARM Mips CellSPU XCore MSP430 Hexagon CBackend CppBackend MBlaze PTX" ;;
++  all) TARGETS_TO_BUILD="X86 Sparc PowerPC ARM Mips CellSPU XCore MSP430 AVR Hexagon CBackend CppBackend MBlaze PTX" ;;
+   *)for a_target in `echo $enableval|sed -e 's/,/ /g' ` ; do
+       case "$a_target" in
+         x86)      TARGETS_TO_BUILD="X86 $TARGETS_TO_BUILD" ;;
+@@ -5247,6 +5250,7 @@ case "$enableval" in
+         spu)      TARGETS_TO_BUILD="CellSPU $TARGETS_TO_BUILD" ;;
+         xcore)    TARGETS_TO_BUILD="XCore $TARGETS_TO_BUILD" ;;
+         msp430)   TARGETS_TO_BUILD="MSP430 $TARGETS_TO_BUILD" ;;
++        avr)      TARGETS_TO_BUILD="AVR $TARGETS_TO_BUILD" ;;
+         hexagon)  TARGETS_TO_BUILD="Hexagon $TARGETS_TO_BUILD" ;;
+         cbe)      TARGETS_TO_BUILD="CBackend $TARGETS_TO_BUILD" ;;
+         cpp)      TARGETS_TO_BUILD="CppBackend $TARGETS_TO_BUILD" ;;
+@@ -5263,6 +5267,7 @@ case "$enableval" in
+             CellSPU|SPU) TARGETS_TO_BUILD="CellSPU $TARGETS_TO_BUILD" ;;
+             XCore)       TARGETS_TO_BUILD="XCore $TARGETS_TO_BUILD" ;;
+             MSP430)      TARGETS_TO_BUILD="MSP430 $TARGETS_TO_BUILD" ;;
++	    AVR)	 TARGETS_TO_BUILD="AVR $TARGETS_TO_BUILD" ;;
+             Hexagon)     TARGETS_TO_BUILD="Hexagon $TARGETS_TO_BUILD" ;;
+             PTX)         TARGETS_TO_BUILD="PTX $TARGETS_TO_BUILD" ;;
+             *)       { { echo "$as_me:$LINENO: error: Can not set target to build" >&5
Index: lib/Target/AVR/README
===================================================================
Index: lib/Target/AVR/scripts/b.sh
===================================================================
--- lib/Target/AVR/scripts/b.sh	(revision 0)
+++ lib/Target/AVR/scripts/b.sh	(revision 0)
@@ -0,0 +1,25 @@
+clear
+export PATH=~/Code/binutils-2.22/install/bin/:$PATH
+echo "Source"
+echo "------"
+cat test.c
+echo "------"
+rm test.elf test.s
+~/Code/llvm/Debug+Asserts/bin/clang -ccc-host-triple avr-pc-linux-gnu test.c -o test.elf -v -mavrxmega5 -O4
+echo "Disassembly"
+echo "----------"
+echo avr-objdump -d test.elf
+avr-objdump -d test.elf
+echo "----------"
+
+#/home/saaadhu/Code/llvm/Debug+Asserts/bin/llc test.ll -march=avr -mtriple=avr -print-after-all -view-dag-combine1-dags 2>&1 > op
+#/home/saaadhu/Code/llvm/Debug+Asserts/bin/llc test.ll -march=avr -mtriple=avr 2>&1 > op
+#cat op
+#/home/saaadhu/Code/binutils-2.22/install/bin/avr-as test.s -o test.elf
+#/home/saaadhu/Code/binutils-2.22/install/bin/avr-objdump -d test.elf
+~
+~
+~
+~
+~
+
Index: lib/Target/AVR/scripts/bi.sh
===================================================================
--- lib/Target/AVR/scripts/bi.sh	(revision 0)
+++ lib/Target/AVR/scripts/bi.sh	(revision 0)
@@ -0,0 +1,19 @@
+clear
+export PATH=~/Code/binutils-2.22/install/bin/:$PATH
+echo "Source"
+echo "------"
+cat test.c
+echo "------"
+rm test.elf test.s test.o test.ll
+~/Code/llvm/Debug+Asserts/bin/clang -ccc-host-triple avr-pc-linux-gnu -S test.c -o test.ll -v -mavrxmega5 -O4 
+echo "Running llc"
+echo "------"
+~/Code/llvm/Debug+Asserts/bin/llc -march=avr -mtriple=avr test.ll -o test.s 
+avr-as test.s -o test.o -mmcu=atxmega128a1
+avr-ld test.o -o test.elf -mavrxmega7 -e test
+echo "Disassembly"
+echo "----------"
+echo avr-objdump -d test.elf
+avr-objdump -d test.elf
+echo "----------"
+cp test.elf ~/llvmoutput
Index: lib/Target/AVR/scripts/bl.sh
===================================================================
--- lib/Target/AVR/scripts/bl.sh	(revision 0)
+++ lib/Target/AVR/scripts/bl.sh	(revision 0)
@@ -0,0 +1,23 @@
+clear
+export PATH=~/Code/binutils-2.22/install/bin/:$PATH
+echo "Source"
+echo "------"
+cat $1
+echo "------"
+rm test.elf test.s
+~/Code/llvm/Debug+Asserts/bin/llc -march=avr -mtriple=avr $1  -o test.s -disable-fp-elim
+avr-as test.s -o test.o -mmcu=atxmega128a1
+avr-ld test.o -o test.elf -mavrxmega7 -e main
+echo "Disassembly"
+echo "----------"
+echo avr-objdump -d test.elf
+avr-objdump -d test.elf
+echo "----------"
+cp test.elf ~/llvmoutput
+
+#/home/saaadhu/Code/llvm/Debug+Asserts/bin/llc test.ll -march=avr -mtriple=avr -print-after-all -view-dag-combine1-dags 2>&1 > op
+#/home/saaadhu/Code/llvm/Debug+Asserts/bin/llc test.ll -march=avr -mtriple=avr 2>&1 > op
+#cat op
+#/home/saaadhu/Code/binutils-2.22/install/bin/avr-as test.s -o test.elf
+#
+
Index: lib/Target/AVR/scripts/buildsetup.sh
===================================================================
--- lib/Target/AVR/scripts/buildsetup.sh	(revision 0)
+++ lib/Target/AVR/scripts/buildsetup.sh	(revision 0)
@@ -0,0 +1,35 @@
+#Checkout LLVM
+git clone http://llvm.org/git/llvm.git
+cd llvm
+git checkout -f 859c645310f37f4b5e93a9802ee4ffd0d6bb58f2
+
+#Checkout clang
+cd tools
+git clone http://llvm.org/git/clang.git
+cd clang
+git checkout -f dd4b35
+
+cd ../../lib/Target
+
+#Checkout the AVR port
+git clone git@github.com:saaadhu/AVR.git
+
+cd ../../
+# Patch llvm
+patch -p1 < lib/Target/AVR/patch.diff
+
+cd tools/clang
+# Patch clang
+patch -p1 < ../../lib/Target/AVR/clang_patch.diff
+
+cd ../../../
+#Download GNU binutils for AVR
+wget http://ftp.gnu.org/gnu/binutils/binutils-2.22.tar.bz2
+
+#Extract binutils and build
+tar -xvf binutils-2.22.tar.bz2 -C .
+cd binutils-2.22
+mkdir build install
+cd build
+../configure --prefix=`pwd`/../install --target=avr --disable-nls
+make && make install
Index: lib/Target/AVR/scripts/mounter.sh
===================================================================
--- lib/Target/AVR/scripts/mounter.sh	(revision 0)
+++ lib/Target/AVR/scripts/mounter.sh	(revision 0)
@@ -0,0 +1,2 @@
+sudo mount -t vboxsf LLVMOutput ~/llvmoutput
+sudo mount -t vboxsf LLVMOutput ~/llvmoutput
Index: lib/Target/AVR/TargetInfo/AVRTargetInfo.cpp
===================================================================
--- lib/Target/AVR/TargetInfo/AVRTargetInfo.cpp	(revision 0)
+++ lib/Target/AVR/TargetInfo/AVRTargetInfo.cpp	(revision 0)
@@ -0,0 +1,19 @@
+//===-- AVRTargetInfo.cpp - AVR Target Implementation ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "AVR.h"
+#include "llvm/Support/TargetRegistry.h"
+using namespace llvm;
+
+Target llvm::TheAVRTarget;
+
+extern "C" void LLVMInitializeAVRTargetInfo() { 
+  RegisterTarget<Triple::avr> 
+    X(TheAVRTarget, "avr", "AVR [experimental]");
+}
Index: lib/Target/AVR/TargetInfo/CMakeLists.txt
===================================================================
--- lib/Target/AVR/TargetInfo/CMakeLists.txt	(revision 0)
+++ lib/Target/AVR/TargetInfo/CMakeLists.txt	(revision 0)
@@ -0,0 +1,7 @@
+include_directories( ${CMAKE_CURRENT_BINARY_DIR}/.. ${CMAKE_CURRENT_SOURCE_DIR}/.. )
+
+add_llvm_library(LLVMAVRInfo
+  AVRTargetInfo.cpp
+  )
+
+add_dependencies(LLVMAVRInfo AVRCommonTableGen)
Index: lib/Target/AVR/TargetInfo/LLVMBuild.txt
===================================================================
--- lib/Target/AVR/TargetInfo/LLVMBuild.txt	(revision 0)
+++ lib/Target/AVR/TargetInfo/LLVMBuild.txt	(revision 0)
@@ -0,0 +1,23 @@
+;===- ./lib/Target/AVR/TargetInfo/LLVMBuild.txt -------------*- Conf -*--===;
+;
+;                     The LLVM Compiler Infrastructure
+;
+; This file is distributed under the University of Illinois Open Source
+; License. See LICENSE.TXT for details.
+;
+;===------------------------------------------------------------------------===;
+;
+; This is an LLVMBuild description file for the components in this subdirectory.
+;
+; For more information on the LLVMBuild system, please see:
+;
+;   http://llvm.org/docs/LLVMBuild.html
+;
+;===------------------------------------------------------------------------===;
+
+[component_0]
+type = Library
+name = AVRInfo
+parent = AVR
+required_libraries = MC Support Target
+add_to_library_groups = AVR
Index: lib/Target/AVR/TargetInfo/Makefile
===================================================================
--- lib/Target/AVR/TargetInfo/Makefile	(revision 0)
+++ lib/Target/AVR/TargetInfo/Makefile	(revision 0)
@@ -0,0 +1,15 @@
+##===- lib/Target/AVR/TargetInfo/Makefile ---------------*- Makefile -*-===##
+#
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+#
+##===----------------------------------------------------------------------===##
+LEVEL = ../../../..
+LIBRARYNAME = LLVMAVRInfo
+
+# Hack: we need to include 'main' target directory to grab private headers
+CPPFLAGS = -I$(PROJ_OBJ_DIR)/.. -I$(PROJ_SRC_DIR)/..
+
+include $(LEVEL)/Makefile.common
Index: lib/Target/AVR/tests/bugs/bug1.ll
===================================================================
--- lib/Target/AVR/tests/bugs/bug1.ll	(revision 0)
+++ lib/Target/AVR/tests/bugs/bug1.ll	(revision 0)
@@ -0,0 +1,16 @@
+define i8 @func(i8 %p)
+{
+  ret i8 1;
+}
+
+define i8 @main(i8 %p)
+{
+  %x = alloca i8;
+  store i8 %p, i8* %x;
+  %y = load i8* %x;
+
+  %f = call i8 @func(i8 %y);
+
+  %t = add i8 %y, %f;
+  ret i8 %t;
+}
Index: lib/Target/AVR/tests/bugs/bug1.s
===================================================================
--- lib/Target/AVR/tests/bugs/bug1.s	(revision 0)
+++ lib/Target/AVR/tests/bugs/bug1.s	(revision 0)
@@ -0,0 +1,44 @@
+	.file	"bug1.ll"
+	.text
+	.globl	func
+	.align	2
+	.type	func,@function
+func:                                   ; @func
+; BB#0:
+	push 	r28
+	push 	r29
+	in 	r28, 0x3D
+	in 	r29, 0x3E
+	ldi	r24, 1
+	pop 	r29
+	pop 	r28
+	ret
+.Ltmp0:
+	.size	func, .Ltmp0-func
+
+	.globl	main
+	.align	2
+	.type	main,@function
+main:                                   ; @main
+; BB#0:
+	push 	r28
+	push 	r29
+	in 	r28, 0x3D
+	in 	r29, 0x3E
+	in 	r30, 0x3D
+	sbci 	r30, 2
+	out 	0x3D, r30
+	mov 	r0, r24
+	std	y+1, r0
+	mov 	r24, r0
+	call	func
+	out 	0x3E, r24
+	in 	r24, 0x3E
+	add 	r24, r0
+	pop 	r29
+	pop 	r28
+	ret
+.Ltmp1:
+	.size	main, .Ltmp1-main
+
+
Index: lib/Target/AVR/tests/bugs/bug2.ll
===================================================================
--- lib/Target/AVR/tests/bugs/bug2.ll	(revision 0)
+++ lib/Target/AVR/tests/bugs/bug2.ll	(revision 0)
@@ -0,0 +1,10 @@
+
+define i8 @main(i8 %p)
+{
+  %x = alloca i8;
+  store i8 %p, i8* %x;
+  %y = load i8* %x;
+
+  %t = add i8 %y, 3;
+  ret i8 %t;
+}
Index: lib/Target/AVR/tests/bugs/bug2.s
===================================================================
Index: lib/Target/AVR/tests/bugs/bug3.ll
===================================================================
--- lib/Target/AVR/tests/bugs/bug3.ll	(revision 0)
+++ lib/Target/AVR/tests/bugs/bug3.ll	(revision 0)
@@ -0,0 +1,18 @@
+define i8 @main()
+{
+	%x = call i8 @add_fn(i8 2, i8 3);
+	%y = call i8 @sub_fn(i8 3, i8 2);
+	ret i8 %y;
+}
+
+define i8 @add_fn(i8 %a, i8 %b)
+{
+	%sum = add i8 %a, %b;
+	ret i8 %sum;
+}
+
+define i8 @sub_fn(i8 %a, i8 %b)
+{
+	%diff = sub i8 %a, %b;
+	ret i8 %diff;
+}
Index: lib/Target/AVR/tests/demo/led.ll
===================================================================
--- lib/Target/AVR/tests/demo/led.ll	(revision 0)
+++ lib/Target/AVR/tests/demo/led.ll	(revision 0)
@@ -0,0 +1,46 @@
+define i8 @main()
+{
+	call void @setup();
+
+	%x = call i8 @test(i8 1, i8 1);
+
+	br label %Loop;
+    Loop:
+	br label %Loop;
+}
+
+define void @setup()
+{
+	%vport0_dir = inttoptr i8 16 to i8*;
+
+	;Map PORTE to VPORT0
+	%vpctrla = inttoptr i8 178 to i8*;
+	store i8 4, i8* %vpctrla;
+
+	;Set all pins to output
+	store i8 255, i8* %vport0_dir;
+
+	ret void;
+}
+
+define void @set_leds(i8 %ledstatus)
+{
+	%vport0_out = inttoptr i8 17 to i8*;
+	store i8 %ledstatus, i8* %vport0_out;
+	ret void;
+}
+
+
+define i8 @test(i8 %a, i8 %b)
+{
+	%cond = icmp eq i8 %a, %b;
+	br i1 %cond, label %Equal, label %Not_equal;
+
+	Equal:
+	   call void @set_leds(i8 240);
+	   ret i8 1;
+    Not_equal:
+	   call void @set_leds(i8 15);
+	   ret i8 2;
+}
+
Index: lib/Target/AVR/tests/demo/test.c
===================================================================
--- lib/Target/AVR/tests/demo/test.c	(revision 0)
+++ lib/Target/AVR/tests/demo/test.c	(revision 0)
@@ -0,0 +1,30 @@
+#define VPORT0_DIR *((char *)(char)16)
+#define VPORT0_OUT *((char *)(char)17)
+
+#define VPCTRL_A *((char *)(char)178)
+
+void setup()
+{
+	 VPCTRL_A = 4; 
+	 VPORT0_DIR = 255;
+}
+
+void setled(char status)
+{
+	VPORT0_OUT = status;
+}
+
+void act()
+{
+	volatile char t = 0;
+	for (;t < 8; t++)
+		setled(t);
+}
+
+void test()
+{
+	setup();
+	setled(255);
+
+}
+
Index: lib/Target/AVR/tests/features/arith.ll
===================================================================
--- lib/Target/AVR/tests/features/arith.ll	(revision 0)
+++ lib/Target/AVR/tests/features/arith.ll	(revision 0)
@@ -0,0 +1,18 @@
+define i8 @main()
+{
+	%x = call i8 @add_fn(i8 2, i8 3);
+	%y = call i8 @sub_fn(i8 4, i8 1);
+	ret i8 %y;
+}
+
+define i8 @add_fn(i8 %a, i8 %b)
+{
+	%sum = add i8 %a, %b;
+	ret i8 %sum;
+}
+
+define i8 @sub_fn(i8 %a, i8 %b)
+{
+	%diff = sub i8 %a, %b;
+	ret i8 %diff;
+}
Index: lib/Target/AVR/tests/features/boolean_logic.ll
===================================================================
--- lib/Target/AVR/tests/features/boolean_logic.ll	(revision 0)
+++ lib/Target/AVR/tests/features/boolean_logic.ll	(revision 0)
@@ -0,0 +1,32 @@
+define i8 @main()
+{
+  %x1 = call i8 @and_func(i8 15,i8 8);
+  %x2 = call i8 @or_func(i8 1,i8 2);
+  %x3 = call i8 @xor_func(i8 1, i8 3);
+
+  %x4 = and i8 %x3, 10;
+  %x5 = or i8 %x4, 4;
+  %x6 = xor i8 %x5, 1;
+  %x7 = add i8 %x6, 99;
+
+  ret i8 %x7;
+}
+
+define i8 @and_func(i8 %t1, i8 %t2)
+{
+  %res = and i8 %t1, %t2;
+  ret i8 %res;
+}
+
+define i8 @or_func(i8 %t1, i8 %t2)
+{
+  %res = or i8 %t1, %t2;
+  ret i8 %res;
+}
+
+define i8 @xor_func(i8 %t1, i8 %t2)
+{
+  %res = xor i8 %t1, %t2;
+  ret i8 %res;
+}
+
Index: lib/Target/AVR/tests/features/cond.ll
===================================================================
--- lib/Target/AVR/tests/features/cond.ll	(revision 0)
+++ lib/Target/AVR/tests/features/cond.ll	(revision 0)
@@ -0,0 +1,17 @@
+define i8 @main()
+{
+	%x = call i8 @test(i8 1, i8 2);
+	ret i8 %x;
+}
+
+define i8 @test(i8 %a, i8 %b)
+{
+	%cond = icmp eq i8 %a, %b;
+	br i1 %cond, label %Equal, label %Not_equal;
+
+	Equal:
+	   ret i8 1;
+    Not_equal:
+	   ret i8 2;
+}
+
Index: lib/Target/AVR/tests/features/const.ll
===================================================================
--- lib/Target/AVR/tests/features/const.ll	(revision 0)
+++ lib/Target/AVR/tests/features/const.ll	(revision 0)
@@ -0,0 +1,5 @@
+define i8 @main()
+{
+	%x = add i8 100, 42;
+	ret i8 %x;
+}
Index: lib/Target/AVR/tests/features/infinite_loop.ll
===================================================================
--- lib/Target/AVR/tests/features/infinite_loop.ll	(revision 0)
+++ lib/Target/AVR/tests/features/infinite_loop.ll	(revision 0)
@@ -0,0 +1,14 @@
+define void @main(i8 %a, i8 %b)
+{
+	br label %Begin;
+	Begin:
+	%cond = icmp eq i8 %a, %b;
+	br i1 %cond, label %Equal, label %Not_equal;
+
+	Equal:
+		br label %Begin;
+	Not_equal:
+		br label %Begin;
+	
+	ret void;
+}
Index: lib/Target/AVR/tests/features/locals.ll
===================================================================
--- lib/Target/AVR/tests/features/locals.ll	(revision 0)
+++ lib/Target/AVR/tests/features/locals.ll	(revision 0)
@@ -0,0 +1,13 @@
+define i8 @main()
+{
+	%x = alloca i8;
+	%y = alloca i8;
+
+	store i8 1, i8* %x;
+	store i8 2, i8* %y;
+
+	%x_val = load i8* %x;
+	%y_val = load i8* %y;
+
+	ret i8 %x_val;
+}
Index: lib/Target/AVR/tests/features/mem.ll
===================================================================
--- lib/Target/AVR/tests/features/mem.ll	(revision 0)
+++ lib/Target/AVR/tests/features/mem.ll	(revision 0)
@@ -0,0 +1,23 @@
+define i8 @main()
+{
+	%vport0_dir = inttoptr i8 16 to i8*;
+	%vport0_out = inttoptr i8 17 to i8*;
+
+	;Map PORTE to VPORT0
+	%vpctrla = inttoptr i8 178 to i8*;
+	store i8 4, i8* %vpctrla;
+
+	;Set all pins to output
+	store i8 255, i8* %vport0_dir;
+
+	;Turn on all the pins
+	store i8 0, i8* %vport0_out;
+
+	;Read the value of the port back
+	%vport0_out_1 = inttoptr i8 19 to i8*;
+	%x = load i8* %vport0_out_1;
+
+	ret i8 %x;
+}
+
+
Index: lib/Target/AVR/tests/features/shifts.ll
===================================================================
--- lib/Target/AVR/tests/features/shifts.ll	(revision 0)
+++ lib/Target/AVR/tests/features/shifts.ll	(revision 0)
@@ -0,0 +1,26 @@
+define i8 @main()
+{
+  %x = call i8 @shr_func(i8 20);
+  %y = call i8 @shl_func(i8 20);
+  %z = call i8 @shra_func(i8 20);
+  ret i8 %z;
+}
+
+define i8 @shr_func(i8 %t)
+{
+  %x = lshr i8 %t, 2;
+  ret i8 %x;
+}
+
+define i8 @shl_func(i8 %t)
+{
+  %x = shl i8 %t, 2;
+  ret i8 %x;
+}
+
+define i8 @shra_func(i8 %t)
+{
+  %x = ashr i8 %t, 2;
+  ret i8 %x;
+}
+
Index: lib/Target/LLVMBuild.txt
===================================================================
--- lib/Target/LLVMBuild.txt	(revision 202846)
+++ lib/Target/LLVMBuild.txt	(working copy)
@@ -16,7 +16,7 @@
 ;===------------------------------------------------------------------------===;
 
 [common]
-subdirectories = AArch64 ARM CppBackend Hexagon MBlaze MSP430 NVPTX Mips PowerPC R600 Sparc SystemZ X86 XCore
+subdirectories = AArch64 ARM CppBackend Hexagon MBlaze MSP430 AVR NVPTX Mips PowerPC R600 Sparc SystemZ X86 XCore
 
 ; This is a special group whose required libraries are extended (by llvm-build)
 ; with the best execution engine (the native JIT, if available, or the
